<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZxysHexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-30T09:00:23.020Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zouxxyy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hadoop-MapReduce流程解析</title>
    <link href="http://yoursite.com/2019/08/30/hadoop-MapReduce%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/08/30/hadoop-MapReduce流程解析/</id>
    <published>2019-08-30T08:38:07.000Z</published>
    <updated>2019-08-30T09:00:23.020Z</updated>
    
    <content type="html"><![CDATA[<p>介绍了MapReduce的详细流程和一些总结</p><a id="more"></a><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="https://github.com/Zouxxyy/bigdata-learning/master/hadoop-learning/data/image/MapTask.png?raw=true" alt="MapTask流程图" title="MapTask流程图"></p><p><img src="https://github.com/Zouxxyy/bigdata-learning/master/hadoop-learning/data/image/ReduceTask.png?raw=true" alt="ReduceTask流程图" title="ReduceTask流程图"></p><p><img src="https://github.com/Zouxxyy/bigdata-learning/master/hadoop-learning/data/image/Shuffer.png?raw=true" alt="Shuffer流程图" title="Shuffer流程图"></p><h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><p>逻辑上可以这样划分：1-10是MapTask ；11-16是ReduceTask；7-14是shuffer</p><h3 id="1-待处理文本"><a href="#1-待处理文本" class="headerlink" title="1. 待处理文本"></a><strong>1. 待处理文本</strong></h3><p>这里假设是<code>/user/input</code>目录下的<code>ss.txt</code>    文件，大小为<strong>200M</strong>。</p><h3 id="2-客户端submit（）"><a href="#2-客户端submit（）" class="headerlink" title="2. 客户端submit（）"></a><strong>2. 客户端submit（）</strong></h3><p>发生在client端，主要获取3个信息：</p><p>（1）<strong>Job.split</strong> ：找到文件ss.txt，根据切片算法，得到切片的元数据信息（起始位置，长度以及所在节点等）如把ss.txt分成两片 0-128M 和 128M-200M</p><p>（2）<strong>Job.xml</strong>：任务的配置信息</p><p>（3）<strong>wc.jar</strong>：任务的jar包</p><p>（可以在<code>/tmp/hadoop-zxy/mapred/staging/zxy1248702679/.staging/</code>下找到它们）</p><h3 id="3-提交信息"><a href="#3-提交信息" class="headerlink" title="3. 提交信息"></a><strong>3. 提交信息</strong></h3><p>将刚刚获取的任务规划信息，提交到资源管理器上，我们这里用Yarn。</p><h3 id="4-RM计算MapTask数量"><a href="#4-RM计算MapTask数量" class="headerlink" title="4. RM计算MapTask数量"></a><strong>4. RM计算MapTask数量</strong></h3><p>接着向Yarn的RM申请资源，RM根据任务规划信息用户Job分成Task，并把任务下发给节点。这里我们数据分成了2片，根据默认规则，会有2个MapTask各自处理一片数据。</p><h3 id="5-根据采用的InputFormat读取数据"><a href="#5-根据采用的InputFormat读取数据" class="headerlink" title="5. 根据采用的InputFormat读取数据"></a><strong>5. 根据采用的InputFormat读取数据</strong></h3><p>这里采用默认的TextInputFormat类，按行读取每条记录。key是行偏移量，value是该行的内容。</p><h3 id="6-执行Mapper的map"><a href="#6-执行Mapper的map" class="headerlink" title="6. 执行Mapper的map()"></a><strong>6. 执行Mapper的map()</strong></h3><p>根据用户的代码执行map逻辑，把结果写入Context中。</p><h3 id="7-向环形缓存区写入数据"><a href="#7-向环形缓存区写入数据" class="headerlink" title="7. 向环形缓存区写入数据"></a><strong>7. 向环形缓存区写入数据</strong></h3><p>环形缓存区取一点：一边写索引，一边写真实数据。达到80%时发生溢写</p><h3 id="8-分区、排序"><a href="#8-分区、排序" class="headerlink" title="8. 分区、排序"></a><strong>8. 分区、排序</strong></h3><p>一种2次排序，先按区号排，再对key排序（快排）。得到一组按区排好序的数据。注意：这步是在环形缓存区就可以执行的，且排序排的是索引，真实数据不用动。且此时可以使用第一次Combiner合并操作。</p><h3 id="9-溢出写入文件"><a href="#9-溢出写入文件" class="headerlink" title="9. 溢出写入文件"></a><strong>9. 溢出写入文件</strong></h3><p>环形缓存区达到80%时，溢写到磁盘上。注意写磁盘前已经完成了分区、排序、合并、压缩等操作。此时生成第一组溢写文件<code>spillN.out</code> 与元数据<code>spillN.out.index</code>。</p><h3 id="10-MapTask的归并排序"><a href="#10-MapTask的归并排序" class="headerlink" title="10. MapTask的归并排序"></a><strong>10. MapTask的归并排序</strong></h3><p>将多组溢写文件，以分区为单位进行归并排序，写入磁盘形成大文件<code>output/file.out</code>，与索引文件<code>output/file.out.index</code>。此时一个MapTask任务完成，得到一个分区有序的数据。注意：在归并排序时可以使用第二次Combiner合并操作。</p><h3 id="11-启动ReduceTask"><a href="#11-启动ReduceTask" class="headerlink" title="11. 启动ReduceTask"></a><strong>11. 启动ReduceTask</strong></h3><p>假设分区数为2，此时启动2个ReduceTask，一个ReduceTask处理一个区的数据。</p><h3 id="12-copy数据"><a href="#12-copy数据" class="headerlink" title="12. copy数据"></a><strong>12. copy数据</strong></h3><p>ReduceTask从各个MapTask上拷贝它要处理的区的数据，如果其大小超过一定阈值，则写到磁盘上，否则直接放到内存中。</p><h3 id="13-ReduceTask的归并排序"><a href="#13-ReduceTask的归并排序" class="headerlink" title="13. ReduceTask的归并排序"></a><strong>13. ReduceTask的归并排序</strong></h3><p>把同区的数据复制到同一个ReduceTask后，对它们进行归并排序</p><h3 id="14-分组"><a href="#14-分组" class="headerlink" title="14. 分组"></a><strong>14. 分组</strong></h3><p>默认把key相同的数据分到一组。用户可以继承WritableComparator，自定义分组规则。</p><h3 id="15-执行Reducer的Reduce"><a href="#15-执行Reducer的Reduce" class="headerlink" title="15. 执行Reducer的Reduce()"></a><strong>15. 执行Reducer的Reduce()</strong></h3><p>根据用户的代码执行reduce逻辑，把结果写入Context中。注意：一次读一组，value是迭代器对象，包含一个组的全部数据。</p><h3 id="16-根据采用的OutputFormat读取数据"><a href="#16-根据采用的OutputFormat读取数据" class="headerlink" title="16. 根据采用的OutputFormat读取数据"></a><strong>16. 根据采用的OutputFormat读取数据</strong></h3><p>这里采用默认的TextOutputFormat类，按行写入key和value，key和value用tab分开。</p><h1 id="一些总结"><a href="#一些总结" class="headerlink" title="一些总结"></a>一些总结</h1><h3 id="1个逻辑"><a href="#1个逻辑" class="headerlink" title="1个逻辑"></a><strong>1个逻辑</strong></h3><p><strong>先分区 -&gt; 再排序 -&gt; 再分组</strong></p><p>分区：用户定义分区数后，默认按hash分区。用户也可以继承<code>Partitioner</code>，自定义分区规则。ReduceTask的个数一般等于分区数。</p><p>排序：默认对key排序，key必须实现<code>WritableComparable</code>接口。用户可以重写<code>WritableComparable</code>接口的<code>compareTo()</code>方法，定义自己的排序规则。</p><h3 id="2次合并"><a href="#2次合并" class="headerlink" title="2次合并"></a><strong>2次合并</strong></h3><p>Combiner的父类就是Reducer，它可以通过对Map阶段的局部结果进行汇总，减少输出。</p><p>时机： 2次，<strong>分区排序后、MapTask的归并排序时</strong>。</p><p>条件：不能影响业务逻辑 且 输入输出的范型一致</p><h3 id="3次排序"><a href="#3次排序" class="headerlink" title="3次排序"></a><strong>3次排序</strong></h3><p>MapTask：</p><p><strong>分区排序</strong>：在缓行缓冲区进行，是一种2次排序。先按分区号排序，再对key排序（快排）。</p><p><strong>归并排序</strong>：对每组溢写的数据，进行的按区，归并排序。</p><p>ReduceTask：</p><p><strong>归并排序</strong>：对从MapTask拷贝的同区数据，进行的归并排序。</p><h3 id="分片和分区"><a href="#分片和分区" class="headerlink" title="分片和分区"></a><strong>分片和分区</strong></h3><p>分片：<strong>分片数决定MapTask的个数</strong>。在客户端即完成，举FileInputFormat切片机制为例：简单的按文件长度进行切片，切片大小等于块大小（默认128M），切片时是对文件单独切片。</p><p>分区：<strong>分区数决定ReduceTask的个数</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍了MapReduce的详细流程和一些总结&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
      <category term="mapreduce" scheme="http://yoursite.com/tags/mapreduce/"/>
    
  </entry>
  
  <entry>
    <title>hadoop-单节点伪分布式搭建</title>
    <link href="http://yoursite.com/2019/08/24/hadoop-%E5%8D%95%E8%8A%82%E7%82%B9%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/08/24/hadoop-单节点伪分布式搭建/</id>
    <published>2019-08-24T03:43:32.000Z</published>
    <updated>2019-08-24T03:45:18.483Z</updated>
    
    <content type="html"><![CDATA[<p>在mac上搭建hadoop伪分布式</p><a id="more"></a><p>操作系统： macOS Mojave 10.14.5</p><p>JDK : 1.8</p><p>hadoop: 2.7.7</p><h2 id="1-Java和Hadoop安装"><a href="#1-Java和Hadoop安装" class="headerlink" title="1. Java和Hadoop安装"></a>1. Java和Hadoop安装</h2><p>下载和安装相信都没问题</p><p>注意的就是：</p><ul><li>环境变量设置好，我是mac所以javahome是$(/usr/libexec/java_home);我是zsh所以修改.zshrc，修改完别忘了source。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#JAVA_HOME</span><br><span class="line">export JAVA_HOME=$(/usr/libexec/java_home)</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">#HADOOP_HOME</span><br><span class="line">export HADOOP_HOME=/usr/local/hadoop-2.7.7</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br></pre></td></tr></table></figure><ul><li>由于我将hadoop放在<code>/usr/local/</code>目录下，所以需要更改hadoop文件夹权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R zxy:admin /usr/local/hadoop-2.7.7</span><br></pre></td></tr></table></figure><h2 id="2-配置SSH"><a href="#2-配置SSH" class="headerlink" title="2. 配置SSH"></a>2. 配置SSH</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -P <span class="string">""</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">ssh localhost</span><br></pre></td></tr></table></figure><h2 id="3-伪分布式配置"><a href="#3-伪分布式配置" class="headerlink" title="3. 伪分布式配置"></a>3. 伪分布式配置</h2><h3 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h3><p>修改 <code>/usr/local/hadoop-2.7.7/etc/hadoop/core-site.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/usr/local/hadoop-2.7.7/data/tmp&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><ul><li><p><strong>fs.defaultFS</strong>  HDFS 的NameNode地址</p></li><li><p><strong>hadoop.tmp.dir</strong>  hadoop 临时文件地址，自己指定</p></li></ul><h3 id="hdfs-site-xml"><a href="#hdfs-site-xml" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h3><p>修改 <code>/usr/local/hadoop-2.7.7/etc/hadoop/hdfs-site.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">            &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>dfs.replication</strong>  HDFS文件存储的副本个数，默认3。因为我们这只有一个节点，所以设置1.（单一节点至多存一份节点）</li></ul><h3 id="yarn-site-xml"><a href="#yarn-site-xml" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h3><p>修改 <code>/usr/local/hadoop-2.7.7/etc/hadoop/yarn-site.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;localhost&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- 开启聚合日志 --&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.log.server.url&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;http://localhost:19888/jobhistory/logs&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>arn.log-aggregation-enable</strong> 开启日志聚合</li><li><strong>yarn.resourcemanager.hostname</strong>  yarn的ResourceManager地址</li></ul><h3 id="mapred-site-xml"><a href="#mapred-site-xml" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h3><p>修改 <code>/usr/local/hadoop-2.7.7/etc/hadoop/mapred-site.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;localhost:10020&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;localhost:19888&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>mapreduce.framework.name</strong>  采用yarn管理MR</li><li><strong>mapreduce.jobhistory.address</strong>  历史服务器端口地址</li><li><strong>mapreduce.jobhistory.webapp.address</strong>  历史服务器web端地址</li></ul><h3 id="检查JAVA-HOME"><a href="#检查JAVA-HOME" class="headerlink" title="检查JAVA_HOME"></a>检查JAVA_HOME</h3><p>hadoop-env.sh、mapred-env.sh、yarn-env.sh，在这三个文件检查是否添加JAVA_HOME路径，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=$JAVA_HOME</span><br></pre></td></tr></table></figure><h2 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h2><ul><li>开HDFS</li></ul><p>第一次使用要格式化(仅限第一次使用时，以后要格式化需删除log、data目录下的文件)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop namenode -format</span><br></pre></td></tr></table></figure><p>开启namenode、datanode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop-daemon.sh start namenode</span><br><span class="line">hadoop-daemon.sh start datanode</span><br></pre></td></tr></table></figure><ul><li>开yarn</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn-daemon.sh start resourcemanager</span><br><span class="line">yarn-daemon.sh start nodemanager</span><br></pre></td></tr></table></figure><ul><li>开historyserver</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mr-jobhistory-daemon.sh start historyserver</span><br></pre></td></tr></table></figure><ul><li>可以用jps查看效果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br><span class="line">35953 JobHistoryServer</span><br><span class="line">32930</span><br><span class="line">35682 NodeManager</span><br><span class="line">35990 Jps</span><br><span class="line">35559 DataNode</span><br><span class="line">35624 ResourceManager</span><br><span class="line">35502 NameNode</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><p>创建一个文件夹zxytest，里面随便放一个文件，上传到hdfs测试wordcount</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -put zxytest /</span><br><span class="line">hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.7.jar wordcount /zxytest /zxyout</span><br></pre></td></tr></table></figure><ul><li>关闭    </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mr-jobhistory-daemon.sh stop historyserver</span><br><span class="line">yarn-daemon.sh stop resourcemanager</span><br><span class="line">yarn-daemon.sh stop nodemanager</span><br><span class="line">hadoop-daemon.sh stop namenode</span><br><span class="line">hadoop-daemon.sh stop datanode</span><br></pre></td></tr></table></figure><ul><li>可视化地址</li></ul><p>所有任务: <a href="http://localhost:8088/" target="_blank" rel="noopener">http://localhost:8088/</a></p><p>DataNode: <a href="http://localhost:50070/" target="_blank" rel="noopener">http://localhost:50070/</a></p><p>历史服务器: <a href="http://localhost:19888/" target="_blank" rel="noopener">http://localhost:19888/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在mac上搭建hadoop伪分布式&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>3种Linux命令后台执行方法：&amp;、nohup、tmux</title>
    <link href="http://yoursite.com/2019/06/26/3%E7%A7%8DLinux%E5%91%BD%E4%BB%A4%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95%EF%BC%9A-%E3%80%81nohup%E3%80%81tmux/"/>
    <id>http://yoursite.com/2019/06/26/3种Linux命令后台执行方法：-、nohup、tmux/</id>
    <published>2019-06-26T03:25:03.000Z</published>
    <updated>2019-06-26T03:28:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>让命令在后台跑起来！</p><a id="more"></a><h1 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h1><p>用法：<code>指令 &amp;</code></p><p>说明： 将指令放入后台执行，会将输出打印到前台，<strong>当执行该指令的终端gg时，它也gg</strong></p><p>终止方法：</p><ul><li><code>jobs</code> 查看它 -&gt; <code>fg %num</code> 取出它 -&gt; <code>Ctrl+c</code>终止它</li><li>直接退出终端</li></ul><h1 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h1><p>用法：<code>nohup 指令 &amp;</code></p><p>说明： 将指令放入后台执行，不会将输出打印到前台，<strong>当执行该指令的终端gg时，它不gg</strong></p><p>终止方法：</p><ul><li>未退出终端时：<code>jobs</code> 查看它 -&gt; <code>fg %num</code> 取出它 -&gt; <code>Ctrl+c</code>终止它</li><li>退出终端时：在新终端连接中，找到PID号，kill它</li></ul><h1 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h1><p>简介：</p><p>tmux可以在后台新建一个终端，并且用户退出后创建的终端仍然存在</p><p>用法：</p><ul><li>创建session</li></ul><p><code>tmux new -s $session_name</code></p><ul><li>列出session</li></ul><p><code>tmux ls</code></p><ul><li>临时退出session</li></ul><p><code>Ctrl+b d</code> </p><ul><li>进入已存在的session</li></ul><p><code>tmux a -t $session_name</code></p><ul><li>删除指定session</li></ul><p><code>tmux kill-session -t $session_name</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>&amp;  简单，安全，退出终端，程序自动结束</p></li><li><p>nohup 退出终端后，必须通过pid号杀程序</p></li><li><p>tmux 谁用谁知道，一般情况，时间长的程序，我都用它 </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;让命令在后台跑起来！&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>用jupyter notebook打开服务器（告别黑框框)</title>
    <link href="http://yoursite.com/2019/04/11/%E7%94%A8jupyter-notebook%E6%89%93%E5%BC%80%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%91%8A%E5%88%AB%E9%BB%91%E6%A1%86%E6%A1%86/"/>
    <id>http://yoursite.com/2019/04/11/用jupyter-notebook打开服务器（告别黑框框/</id>
    <published>2019-04-11T07:19:52.000Z</published>
    <updated>2019-04-11T07:34:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>几步完成服务器内jupyter notebook的使用</p><a id="more"></a><h1 id="为啥要这样"><a href="#为啥要这样" class="headerlink" title="为啥要这样"></a>为啥要这样</h1><p>可以远程用浏览器看服务器的文件目录，以及各种jupyter的好处：直接改代码，调试，它内嵌的读图也是特别舒服。</p><h1 id="服务器安装jupyter-notebook"><a href="#服务器安装jupyter-notebook" class="headerlink" title="服务器安装jupyter notebook"></a>服务器安装jupyter notebook</h1><p>我是给服务器装了<a href="https://zouxxyy.github.io/2019/04/10/linux%E4%B8%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%89%E8%A3%85anaconda3-pytorch-fastai/#more" target="_blank" rel="noopener">anaconda</a>，然后就自带了jupyter notebook。</p><h1 id="配置jupyter-notebook"><a href="#配置jupyter-notebook" class="headerlink" title="配置jupyter notebook"></a>配置jupyter notebook</h1><ol><li>登陆服务器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@address_of_remote</span><br></pre></td></tr></table></figure><ol start="2"><li>生成配置文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jupyter notebook --generate-config</span><br></pre></td></tr></table></figure><p>该指令会自动创建这个：<code>~/.jupyter/jupyter_notebook_config.py</code></p><ol start="3"><li>生成密码</li></ol><p>打开python，创建密码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> notebook.auth <span class="keyword">import</span> passwd</span><br><span class="line">passwd()</span><br><span class="line">Enter password:</span><br><span class="line">Verify password:</span><br><span class="line"><span class="string">'sha1:xxxxxxxxxxxxxxxxxxxxxxx'</span></span><br></pre></td></tr></table></figure><p>把密码<code>&#39;sha1:xxxxxxxxxxxxxxxxxxxxxxx&#39;</code>复制下来</p><ol start="4"><li>修改配置文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.jupyter/jupyter_notebook_config.py</span><br></pre></td></tr></table></figure><p>加上下面这几行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.allow_remote_access = <span class="literal">True</span></span><br><span class="line">c.NotebookApp.ip = <span class="string">'*'</span></span><br><span class="line">c.NotebookApp.password = <span class="string">u'sha1:xxxxxxxxxxxxxxxxxxxx'</span> <span class="comment">#你的密码</span></span><br><span class="line">c.NotebookApp.open_browser = <span class="literal">False</span></span><br><span class="line">c.NotebookApp.port = <span class="number">8888</span></span><br></pre></td></tr></table></figure><ol start="5"><li>启动jupyter</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jupyter notebook</span><br></pre></td></tr></table></figure><h1 id="远程访问"><a href="#远程访问" class="headerlink" title="远程访问"></a>远程访问</h1><ul><li><p>方法一： </p><p>  本地浏览器访问<code>http://address_of_remote:8888</code> （此方法可能由于防火墙问题出现失败）</p></li><li><p>方法二： </p><ol><li><p>在本地终端中输入:</p><p><code>ssh username@address_of_remote -L127.0.0.1:1234:127.0.0.1:8888</code></p></li><li><p>本地浏览器访问<code>http://localhost:1234</code></p></li></ol></li></ul><p>看看效果，虚浮了。相逢恨晚，造化弄人啊～</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/11/16a0a4fa59021e90?w=1293&h=200&f=png&s=25969" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几步完成服务器内jupyter notebook的使用&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="jupyter" scheme="http://yoursite.com/tags/jupyter/"/>
    
  </entry>
  
  <entry>
    <title>linux下命令行安装anaconda3+pytorch+fastai</title>
    <link href="http://yoursite.com/2019/04/10/linux%E4%B8%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%89%E8%A3%85anaconda3-pytorch-fastai/"/>
    <id>http://yoursite.com/2019/04/10/linux下命令行安装anaconda3-pytorch-fastai/</id>
    <published>2019-04-10T12:53:35.000Z</published>
    <updated>2019-04-11T07:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>几步完成 anaconda3+pytorch+fastai 的安装</p><a id="more"></a><h1 id="为啥用anaconda"><a href="#为啥用anaconda" class="headerlink" title="为啥用anaconda"></a>为啥用anaconda</h1><p>anaconda 确实很好用，切换python版本也方便。而且如果服务器用的人多，用anaconda搞个自己的环境很舒服。</p><h1 id="anaconda3安装"><a href="#anaconda3安装" class="headerlink" title="anaconda3安装"></a>anaconda3安装</h1><ol><li><strong><a href="https://www.anaconda.com/distribution/" target="_blank" rel="noopener">官网</a>选择要下载的版本</strong>。我用的是python3.7做base（如果后面想用python2.7直接加个环境就行）</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a0537dfe227c8d?w=1122&h=485&f=png&s=62781" alt></p><p>把下载地址拷贝下来，用<code>wget</code>下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.anaconda.com/archive/Anaconda3-2019.03-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>安装</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash Anaconda3-2019.03-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><p>这个过程需要</p><ol><li>按回车阅读license，并同意</li><li>选择安装地址，我就是按默认的<code>/home/zxy/anaconda3</code></li><li>是否 conda init ，这步同意了会自动在<code>/home/zxy/.bashrc</code>改你的环境变量。</li></ol><ol start="3"><li><strong>激活环境变量的修改</strong> </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>激活下修改，就安装完毕了，然后可以rm掉安装包。</p><ol start="4"><li><strong>一些细节</strong></li></ol><p>同意了<code>conda init</code>后，会<strong>自动</strong>在<code>/home/zxy/.bashrc</code>加下面这些东西。可以用<code>cat ~/.bashrc</code>自己看看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt;&gt;&gt; conda initialize &gt;&gt;&gt;</span></span><br><span class="line"><span class="comment"># !! Contents within this block are managed by 'conda init' !!</span></span><br><span class="line">__conda_setup=<span class="string">"<span class="variable">$('/home/zxy/anaconda3/bin/conda' 'shell.bash' 'hook' 2&gt; /dev/null)</span>"</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="string">"<span class="variable">$__conda_setup</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="string">"/home/zxy/anaconda3/etc/profile.d/conda.sh"</span> ]; <span class="keyword">then</span></span><br><span class="line">        . <span class="string">"/home/zxy/anaconda3/etc/profile.d/conda.sh"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">export</span> PATH=<span class="string">"/home/zxy/anaconda3/bin:<span class="variable">$PATH</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">unset</span> __conda_setup</span><br><span class="line"><span class="comment"># &lt;&lt;&lt; conda initialize &lt;&lt;&lt;</span></span><br></pre></td></tr></table></figure><p>有了它呢，我们直接<code>python</code>测试看看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) [zxy@gpu-server5 ~]$ python</span><br><span class="line">Python 3.7.3 (default, Mar 27 2019, 22:11:17) </span><br><span class="line">[GCC 7.3.0] :: Anaconda, Inc. on linux</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> or <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br></pre></td></tr></table></figure><p>OK! 可以用了！</p><h1 id="pytorch安装"><a href="#pytorch安装" class="headerlink" title="pytorch安装"></a>pytorch安装</h1><p> <strong><a href="https://pytorch.org/" target="_blank" rel="noopener">官网</a>选择下载的版本</strong>。这里要根据自己的cuda版本选择</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a0535a5d05c267?w=825&h=316&f=png&s=40869" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision cudatoolkit=9.0 -c pytorch</span><br></pre></td></tr></table></figure><p>因为有了<code>anaconda</code>，安装<code>pytorch</code>一句话完事。</p><p>(ps：国内兄弟，可以先添加<a href="https://mirror.tuna.tsinghua.edu.cn/help/anaconda/" target="_blank" rel="noopener">清华镜像</a>，再把后面的-c pytorch去掉。速度飞起～)</p><h1 id="fastai安装"><a href="#fastai安装" class="headerlink" title="fastai安装"></a>fastai安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c fastai fastai</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几步完成 anaconda3+pytorch+fastai 的安装&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="anaconda" scheme="http://yoursite.com/tags/anaconda/"/>
    
  </entry>
  
  <entry>
    <title>JVM(8)-虚拟机字节码执行引擎</title>
    <link href="http://yoursite.com/2019/03/29/JVM-8-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>http://yoursite.com/2019/03/29/JVM-8-虚拟机字节码执行引擎/</id>
    <published>2019-03-29T08:51:23.000Z</published>
    <updated>2019-03-29T08:53:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是《深入理解Java虚拟机（第二版）》第八章的笔记</p><a id="more"></a><h1 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h1><p>在活动线程中，只有栈顶的栈时有效的，称为<strong>当前栈帧</strong>，与这个栈帧相关联的方法称为<strong>当前方法</strong>。下面对栈帧的4个主要部分进行分析。</p><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>存放方法参数和方法内部定义的局部变量</p><p>一些细节：</p><ul><li>最小存储单元(Slot)，一个Slot可以存32位以内的数据类型。</li><li><code>boolean、byte、char、short、int、float、reference、returnAddress</code>占一个Slot；<code>long、double</code>占两个Slot，是非原子的，但它是<strong>线程安全</strong>的，因为它是栈中的，是线程私有的。</li><li>对于实例方法，第一个Slot是传递所属对象实例的引用，也就是我们常用的   <code>this</code>。</li><li>注意局部变量<strong>没有初始值</strong>哦。</li><li>当一个变量的pc寄存器的值大于Slot的作用域时，Slot是可以<strong>复用</strong>的。</li></ul><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><ul><li>虚拟机字节码执行引擎是“<strong>基于栈的执行引擎</strong>”，这个栈就是操作数栈。</li><li>对比<strong>基于寄存器</strong>的执行引擎</li></ul><p>优点：可移植性、代码更加紧凑、编译器实现更紧凑。确定就是速度更慢。</p><ul><li>下面栈帧的部分操作数栈与上面的栈帧的部分局部变量是重叠的。</li></ul><h2 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h2><p>指向运行时常量池中该栈帧所属方法的引用，这个引用的为了支持方法调用过程的动态连接。具体内容在下面的方法调用中解释。</p><h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>方法退出（也就是<strong>当前栈帧出栈</strong>）的两种方式：</p><ul><li><code>return</code>正常退出</li><li>异常退出，根据异常表得返回出口</li></ul><h1 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h1><p>方法调用不等同于方法的执行，方法调用阶段唯一的任务就是确定被调用方法的版本。说白了就是找方法，方法唯一就直接确定（<strong>解析</strong>）。方法不唯一：<strong>重载（静态分配）、重写（动态分配）</strong></p><h2 id="解析调用"><a href="#解析调用" class="headerlink" title="解析调用"></a>解析调用</h2><ul><li><p>调用目标在程序代码写好、编译器进行编译时就确定好的。这类方法时调用称为解析。是静态的。</p></li><li><p><strong>非虚方法</strong>：静态方法、私有方法、实例构造器、父类方法、final方法。它们都是采用解析调用。反之其它就是虚方法。</p></li></ul><h2 id="分派调用"><a href="#分派调用" class="headerlink" title="分派调用"></a>分派调用</h2><p><code>Human man = new Man();</code></p><p><code>Human</code>是静态类型（外观类型），<code>Man</code>是实际类型</p><h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p>依赖静态类型来定位方法执行的版本的分配动作称为静态分配。最典型的应用是方法重载。</p><ul><li>编译器在<strong>重载</strong>时是根据参数的<strong>静态类型</strong>作为依据的。</li><li>由于字面量没有显式的静态类型，它重载时可能会有多种选择，只是选一个更好的版本。</li><li>静态分配和解析不是互斥的，例如静态方法也是可以重载的。</li><li>注意：静态分配更严格，<strong>一定是要用静态类型做参数</strong>。</li></ul><h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p>依赖实际类型来定位方法执行的版本的分配动作称为动态分配。最典型的应用是方法重写。</p><ul><li>虚拟器在<strong>重写</strong>时是对象的<strong>实际类型</strong>作为依据的。</li><li>注意：动态分配更宽松，如果实际类型中没有对应的方法，就会向上找父类里的相同方法来调用。</li></ul><p>一个测试例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MixTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123; &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">choice</span><span class="params">(Human arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose human"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">choice</span><span class="params">(Man arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose man"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">choice</span><span class="params">(Woman arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose woman"</span>); <span class="comment">// 和同一类里的同名方法是重载关系</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">choice</span><span class="params">(Human arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose human"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">choice</span><span class="params">(Man arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose man"</span>); <span class="comment">// 和父类的同名同参数方法是重写关系</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">choice</span><span class="params">(Woman arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose woman"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        Man man = <span class="keyword">new</span> Man();</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Father son = <span class="keyword">new</span> Son();</span><br><span class="line">        father.choice(woman); <span class="comment">// 重写：对象类型选Father(实际类型) 重载：参数类型选 Human（静态类型）</span></span><br><span class="line">        son.choice(man); <span class="comment">// 重写：对象类型选Son(实际类型) 重载：参数类型选 Man（静态类型）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 程序输出：</span></span><br><span class="line"><span class="comment">father choose human</span></span><br><span class="line"><span class="comment">son choose man</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《深入理解Java虚拟机（第二版）》第八章的笔记&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM(7)-虚拟机类加载机制</title>
    <link href="http://yoursite.com/2019/03/29/JVM-7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/03/29/JVM-7-虚拟机类加载机制/</id>
    <published>2019-03-29T08:51:13.000Z</published>
    <updated>2019-03-29T08:52:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是《深入理解Java虚拟机（第二版）》第七章的笔记</p><a id="more"></a><h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><p>类加载后要初始化。所以可以通过判断啥时候要<strong>初始化</strong>，得出类加载的时机。</p><h2 id="有且只有5种情况需要对类进行初始化"><a href="#有且只有5种情况需要对类进行初始化" class="headerlink" title="有且只有5种情况需要对类进行初始化"></a><strong>有且只有5种情况</strong>需要对类进行初始化</h2><ol><li><code>new</code>实例化对象、读取或设置静态字段（被<strong>final修饰放入常量池</strong>时除外）、调用类的静态方法 （且类没有初始化）。</li><li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用，且类没有初始化</li><li>初始化一个类时，如果父类没有初始化，会触发父类的初始化</li><li>含main方法的类会优先初始化</li><li>当使用JDK1.7的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果<code>REF_getStatic、REF_pubStatic、REF_invokeStatic</code>的方法句柄，并且这个句柄对应的类没有初始化，会触发其初始化。（黑人问号。。）</li></ol><h2 id="被动引用的例子"><a href="#被动引用的例子" class="headerlink" title="被动引用的例子"></a>被动引用的例子</h2><ul><li>用子类引用父类的静态字段<code>SubClass.value</code>(value在父类中)，只会初始化父类。</li><li>通过数组来定义引用类，不会触发次类的初始化</li><li><code>final</code>修饰的静态常量会存入常量池，引用它不会触发初始化(可以与上面的第一种情况比较)</li></ul><h2 id="与接口初始化的比较"><a href="#与接口初始化的比较" class="headerlink" title="与接口初始化的比较"></a>与接口初始化的比较</h2><ul><li>接口不能使用static{}语句块，但有<code>&lt;clinit&gt;()</code>类构造器</li><li>与第三条不同：初始化一个接口时，如果父类接口没有初始化，父类接口不会初始化。</li></ul><h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><p><img src="https://user-gold-cdn.xitu.io/2019/3/28/169c226c3ad50652?w=1339&h=609&f=png&s=39162" alt></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>在加载期间虚拟机完成以下三件事：</p><ul><li>通过类的全限定名获取定义此类的二进制字节流</li><li>通过这个二进制流代表的静态存储结构转化为方法区的运行时数据</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口（HotSpot虚拟机中Class对象是 在方法区中）<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2></li><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为类的变量（<strong>static修饰</strong>）分配内存并设置变量的初始值。这些变量所用的内存都在方法区中分配。</p><p>注意：这里的初始值是其<strong>默认值</strong>。如果是<code>static final</code>修饰，就初始化为指定值，存在常量区。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>将虚拟机中的<strong>符号引用</strong>替换为<strong>直接引用</strong></p><p>主要的解析动作</p><ul><li>类或者接口的解析</li><li>字段解析</li><li>类方法的解析</li><li>接口方法的解析</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>执行<code>&lt;clinit&gt;()</code>方法的过程。和<code>&lt;init&gt;()</code>比较下：</p><ul><li><code>&lt;clinit&gt;()</code>：类的初始化，类变量的赋值动作和静态语句块合并一起。</li><li><code>&lt;init&gt;()</code>：类的实例化，也就是类的构造方法。初始化实例用的。</li></ul><p>一些细节：</p><ul><li><p>定义在静态语句块后面的变量，静态语句块可以赋值但不能访问。如果访问会报错“<strong>非法前向引用</strong>”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Clinit &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        i = 0;</span><br><span class="line">        // System.out.println(i); // 非法前向引用</span><br><span class="line">    &#125;</span><br><span class="line">    static int i = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优先执行父类的<code>&lt;clinit&gt;()</code>方法</p></li><li><p>接口的父类<code>&lt;clinit&gt;()</code>方法不需要先执行，并且接口的实现类在初始化时也不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p></li><li><p>如果多个线程同时初始化一个类，只有一个线程会执行类的<code>&lt;clinit&gt;()</code>方法。</p></li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>类加载器干的事：通过类的全限定名获取定义此类的二进制字节流。只有被同一个类加载器所加载的类才有可能相等。</p><p>优势：<strong>类层次划分</strong>、OSGi、热部署、<strong>代码加密</strong> 等等。</p><p>类加载器分类</p><ul><li>启动类加载器：c++实现，是虚拟机等一部分，加载<code>&lt;JAVA_HOME&gt;/lib</code>目录下的类</li><li>扩展类加载器：加载<code>&lt;JAVA_HOME&gt;/lib/ext</code>目录下的类</li><li>应用程序类加载器：加载用户路径上指定的类库</li><li>自定义类加载器：用户自定义的类加载器</li></ul><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p><img src="https://user-gold-cdn.xitu.io/2019/3/28/169c226f3fdffe17?w=468&h=359&f=png&s=122552" alt></p><ul><li>要求：除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。</li><li>过程：就是把加载的活<strong>推拖</strong>给父类加载器，一直推到最顶层。然后让最顶层加载器加载，如果它干不了，再递给子，直到推给发起者，如果它也干不了，就发出 <code>ClassNotFoundException</code>异常。</li><li>优点：使类有类层次性。如在双亲委派模型下，Object类是由最顶层的启动类加载器加载，所以它在每种加载器中都是同一个类，使Object这一最基础的类的性能得以保证。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《深入理解Java虚拟机（第二版）》第七章的笔记&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM(4)-虚拟机性能监控与故障处理工具</title>
    <link href="http://yoursite.com/2019/03/25/JVM-4-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2019/03/25/JVM-4-虚拟机性能监控与故障处理工具/</id>
    <published>2019-03-25T09:14:42.000Z</published>
    <updated>2019-03-25T09:15:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是《深入理解Java虚拟机（第二版）》第四章的笔记</p><a id="more"></a><p>我的JDK工具地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">zxysMac:~ elwg$ <span class="built_in">cd</span> /Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/bin</span><br><span class="line">zxysMac:bin elwg$ ls</span><br><span class="line">appletviewerjavahjjsjvisualvmschemagen</span><br><span class="line">extcheckjavapjmapkeytoolserialver</span><br><span class="line">idljjavapackagerjmcnative2asciiservertool</span><br><span class="line">jarjcmdjpsorbdtnameserv</span><br><span class="line">jarsignerjconsolejrunscriptpack200unpack200</span><br><span class="line">javajdbjsadebugdpolicytoolwsgen</span><br><span class="line">javacjdepsjstackrmicwsimport</span><br><span class="line">javadocjhatjstatrmidxjc</span><br><span class="line">javafxpackagerjinfojstatdrmiregistry</span><br></pre></td></tr></table></figure><h1 id="JDK的命令行工具"><a href="#JDK的命令行工具" class="headerlink" title="JDK的命令行工具"></a>JDK的命令行工具</h1><table><thead><tr><th>名称</th><th>全名</th><th>主要功能</th></tr></thead><tbody><tr><td>jps</td><td>JVM Process Status</td><td>显示指定系统的所有的虚拟机进程</td></tr><tr><td>jstat</td><td>JVM Statistics Monitoring Tool</td><td>用于收集虚拟机各方面的运行数据</td></tr><tr><td>jinfo</td><td>Configuration Info for Java</td><td>显示虚拟机配置信息</td></tr><tr><td>jmap</td><td>Memory Map for Java</td><td>生成虚拟机的内存转储快照（heapdump文件）</td></tr><tr><td>jhat</td><td>JVM Heap Dump Browser</td><td>用于分析heapdump文件</td></tr><tr><td>jstack</td><td>Stack Trace for Java</td><td>显示虚拟机的线程快照</td></tr><tr><td>## jps：虚拟机进程状况工具</td><td></td><td></td></tr><tr><td>- 功能：可以列出运行的虚拟机进程、看到虚拟机执行的主类、本地虚拟机唯一ID</td><td></td><td></td></tr></tbody></table><ul><li>命令格式：<br><code>jps [ option ] [ hostid ]</code></li><li>主要选项：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169a9a09b0013234?w=918&h=205&f=png&s=96305" alt></p><ul><li>例子：我在IDEA中运行列一个java文件，测试如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) zxysMac:~ elwg$ jps -l</span><br><span class="line">16387 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class="line">44422 sun.tools.jps.Jps</span><br><span class="line">44392 com.zouxxyy.jvm.chap4.JpsTest</span><br><span class="line">31368 org.jetbrains.kotlin.daemon.KotlinCompileDaemon</span><br><span class="line">16217</span><br><span class="line">44393 org.jetbrains.jps.cmdline.Launcher</span><br></pre></td></tr></table></figure></li></ul><h2 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h2><ul><li>功能：可以显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</li><li>命令格式：<code>jstat [ option vmid [interval[s|ms] [count]] ]</code></li><li>主要选项：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169a9aa3cfd87699?w=923&h=459&f=png&s=275718" alt></p><h2 id="jinfo：Java配置信息工具"><a href="#jinfo：Java配置信息工具" class="headerlink" title="jinfo：Java配置信息工具"></a>jinfo：Java配置信息工具</h2><ul><li><p>功能：实时查看和调整虚拟机各项参数</p></li><li><p>命令格式：<code>jinfo [ option ] pid</code></p></li><li><p>例子：看有没有用SerialGC</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) zxysMac:~ elwg$ jinfo -flag UseSerialGC 46521</span><br><span class="line">-XX:-UseSerialGC</span><br></pre></td></tr></table></figure><h2 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h2><ul><li>功能：生成虚拟机堆存转储快照（heapdump文件）</li><li>命令格式：<code>jmap [ option] vmid</code></li><li>主要选项：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169a9b5409980aff?w=933&h=403&f=png&s=202391" alt></p><h2 id="jhat：虚拟机堆快照分析工具"><a href="#jhat：虚拟机堆快照分析工具" class="headerlink" title="jhat：虚拟机堆快照分析工具"></a>jhat：虚拟机堆快照分析工具</h2><p>与jmap配合使用，也就是分析堆存转储快照（heapdump文件）。</p><h2 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h2><ul><li>功能：用于生成虚拟机的线程快照</li><li>命令格式：<code>jstack [ option ] vmid</code></li><li>主要选项：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169a9b95790bdcd5?w=920&h=188&f=png&s=81541" alt></p><h1 id="JDK的可视化工具"><a href="#JDK的可视化工具" class="headerlink" title="JDK的可视化工具"></a>JDK的可视化工具</h1><h2 id="JConsole：Java监视与管理控制台"><a href="#JConsole：Java监视与管理控制台" class="headerlink" title="JConsole：Java监视与管理控制台"></a>JConsole：Java监视与管理控制台</h2><p><strong>内存监控，相当于可视化的<code>jstat</code>命令</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b291ef7f36929?w=858&h=628&f=png&s=106536" alt><br><strong>线程监控，相当于可视化的<code>jstack</code>命令</strong>，以下举几个简单的例子</p><ul><li>监听用户键盘输入</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b2a74ba142acd?w=811&h=134&f=png&s=29000" alt></p><ul><li>监听wait()</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b2a7c8556a816?w=819&h=206&f=png&s=45681" alt></p><ul><li>监听死锁</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b2bdcdb14d52d?w=844&h=306&f=png&s=35573" alt></p><h2 id="VisualVM：多合一故障处理工具"><a href="#VisualVM：多合一故障处理工具" class="headerlink" title="VisualVM：多合一故障处理工具"></a>VisualVM：多合一故障处理工具</h2><p>书上说它很强大，我还没下载成功。它几乎集成里上面的所有功能啊。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b2e570ebb1cc5?w=1239&h=665&f=png&s=126621" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《深入理解Java虚拟机（第二版）》第四章的笔记&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM(3)-垃圾收集器与内存分配策略</title>
    <link href="http://yoursite.com/2019/03/25/JVM-3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2019/03/25/JVM-3-垃圾收集器与内存分配策略/</id>
    <published>2019-03-25T09:14:12.000Z</published>
    <updated>2019-03-25T09:15:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是《深入理解Java虚拟机（第二版）》第三章的笔记</p><a id="more"></a><h1 id="如何判断对象为垃圾对象"><a href="#如何判断对象为垃圾对象" class="headerlink" title="如何判断对象为垃圾对象"></a>如何判断对象为垃圾对象</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>给对象添加一个引用计数器，每当有个对象引用它时，计数器加1；引用失效时计数器减1；为0时对象不可能被再引用。</p><p>没有使用的原因：很难解决<strong>对象之间相互循环引用</strong>的问题</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>看作为GC Roots的对象作为起始点，和<strong>它连通的是可用的，反之不可用</strong>。</p><p>如下情况的对象可以作为GC Roots：</p><ul><li>虚拟机栈(栈桢中的本地变量表)、本地方法栈中JNI（Native方法）中的引用的对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><p>当对象不可达时，会执行<code>fianlize()</code>，但该方法自会被自动调用一次，有点像c++的析构函数，书上说最好别用。</p><h2 id="引用的分类"><a href="#引用的分类" class="headerlink" title="引用的分类"></a>引用的分类</h2><ul><li>强引用：<code>Objece obj = new Object()</code>，永远不会被垃圾搜集回收</li><li>软引用：<code>SoftReference</code>类实现，可以存活第一次回收，但第二次就GG</li><li>弱引用：<code>WeakReference</code>类实现，第一次就GG</li><li>虚引用：<code>PhantomReference</code>类实现，<strong>不能通过它取得实例</strong>，唯一作用就是当该对象被回收时会收到一个系统通知。<h1 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h1><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2></li><li>标记-清除算法：（老年代）先标记，再清除。缺点：效率低，内存碎片化</li><li>复制算法：（新生代）HotSpot虚拟机把内存分为Eden和2块Survivor区，把在Eden和Survivor中 存活的对象 复制到空闲的一块Survivor中。不够时可以向老年代担保。</li><li>标记-整理算法：（老年代）标记 -&gt; 移动到一起 -&gt; 清理</li><li>分代收集算法：把内存分为新生代和老年代。根据年代选则合适的算法。<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2></li></ul><table><thead><tr><th>新生代</th><th>老年代</th><th>特殊</th></tr></thead><tbody><tr><td>Serial（单线程）</td><td>Serial Old（单线程，CMS备胎）</td><td>G1（Region优先级回收）</td></tr><tr><td>ParNew（多线程）</td><td>CMS（并发）</td><td></td></tr><tr><td>Parallel Scavenge（关注吞吐量）</td><td></td><td></td></tr><tr><td>- 并行（Parallel）：多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。</td><td></td><td></td></tr><tr><td>- 并发（Concurrent）：用户线程与垃圾收集线程同时执行。</td><td></td><td></td></tr><tr><td># 如何分配</td><td></td><td></td></tr><tr><td>以HosSpot收集器的分配和回收策略为例</td><td></td><td></td></tr><tr><td>- 优先分配在Eden</td><td></td><td></td></tr><tr><td>- <strong>大对象直接进入老年代</strong></td><td></td><td></td></tr><tr><td>- 长期存活的对象进入老年代</td><td></td><td></td></tr><tr><td>- 动态对象年龄判定</td><td></td><td></td></tr><tr><td>- 空间分配担保</td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《深入理解Java虚拟机（第二版）》第三章的笔记&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA 实用快捷键(持续更新)</title>
    <link href="http://yoursite.com/2019/03/22/IntelliJ-IDEA-%E5%AE%9E%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2019/03/22/IntelliJ-IDEA-实用快捷键-持续更新/</id>
    <published>2019-03-22T03:39:12.000Z</published>
    <updated>2019-03-22T03:42:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>IntelliJ IDEA 的小技巧，持续更新哦</p><a id="more"></a><h1 id="码代码"><a href="#码代码" class="headerlink" title="码代码"></a>码代码</h1><h2 id="1-缩写功能"><a href="#1-缩写功能" class="headerlink" title="1. 缩写功能"></a>1. <strong>缩写功能</strong></h2><ul><li><p>方式：一般取首字母即可</p></li><li><p>例子 ：</p></li></ul><p><code>public static void main(String[] args){}</code>可以用 <code>psvm</code>出来<br><img src="https://user-gold-cdn.xitu.io/2019/3/20/1699af88700b10ec?w=659&h=78&f=png&s=15782" alt><br><code>System.out.printf(&quot;&quot;);</code>可以用 <code>souf</code>打出来<br><img src="https://user-gold-cdn.xitu.io/2019/3/20/1699afa70d8e05ee?w=536&h=58&f=png&s=14067" alt>`</p><h2 id="2-创建新函数"><a href="#2-创建新函数" class="headerlink" title="2. 创建新函数"></a>2. <strong>创建新函数</strong></h2><ul><li><p>方式： 选中目标函数，<code>alt + enter</code> 即可</p></li><li><p>例子：</p></li></ul><p>要加的函数：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/20/1699b0142ecd3d26?w=571&h=65&f=png&s=12515" alt><br>生成的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">newfun</span><span class="params">(<span class="keyword">int</span> i, String aa)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-加-surround，如if、catch"><a href="#3-加-surround，如if、catch" class="headerlink" title="3. 加 surround，如if、catch"></a>3. <strong>加 surround，如if、catch</strong></h2><ul><li><p>方式： 选中目标代码段，<code>ctrl + alt + t</code> 再选择surround类型</p></li><li><p>例子：</p></li></ul><p>要加的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">300</span>);</span><br></pre></td></tr></table></figure><p>选中，再<code>ctrl + alt + t</code>：<br><img src="https://user-gold-cdn.xitu.io/2019/3/20/1699b0a77552c0f9?w=666&h=421&f=png&s=62639" alt><br>添加后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IntelliJ IDEA 的小技巧，持续更新哦&lt;/p&gt;
    
    </summary>
    
      <category term="其它" scheme="http://yoursite.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="IDEA" scheme="http://yoursite.com/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>JVM(2)-Java内存区域与内存溢出异常</title>
    <link href="http://yoursite.com/2019/03/22/JVM-2-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2019/03/22/JVM-2-Java内存区域与内存溢出异常/</id>
    <published>2019-03-22T03:38:21.000Z</published>
    <updated>2019-03-22T06:49:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是《深入理解Java虚拟机（第二版）》第二章的笔记</p><a id="more"></a><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/1699e42932e70b62?w=652&h=625&f=png&s=45434" alt><br>我们这节关注中间灰色部分，注意绿色部分<strong>线程共享</strong>，黄色部分<strong>线程私有</strong></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>一块较小的内存，是<strong>当前线程</strong>（线程私有）执行的字节码的<strong>行号指示器</strong>。</p><ul><li>如果执行的是Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果是Native（本地方法），计数器值为空(Undefined)</li><li>唯一没有<code>OutOfMemoryError</code>的区域</li></ul><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>虚拟机栈是描述Java方法执行的内存模型</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/1699f1c41f3b3ba5?w=551&h=419&f=png&s=23533" alt><br>每个方法调用至完成，对应一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>局部变量表：</p><ul><li>存放<strong>基本数据类型</strong>、<strong>对象引用</strong>、<strong>returnAddress</strong></li><li>局部变量表所需的内存空间在<strong>编译期</strong>完成，该空间是确定的，方法运行期间<strong>不改变</strong>。</li></ul><p>两种异常：</p><ul><li><code>StackOverflowError</code>: 请求的栈深度超过允许范围</li><li><code>OutOfMemoryError</code>: 需要的内存超过允许范围<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2>本地方法栈是描述<strong>本地方法</strong>执行的内存模型。它和Java虚拟机栈很类似，区别就是它是为本地方法服务的。<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2>存放对象示例，也称作（GC堆），是垃圾回收器管理的主要区域。</li><li>细分 新生代、老生代；Eden空间、From Survivor空间、To Survivor空间等</li><li>线程共享的堆里可能划分出私有的分配缓冲区（TLAB）。<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2>存储<strong>已被虚拟机加载的类信息</strong>、常量、静态变量、即时编译后的代码等数据。</li></ul><p><strong>运行时常量池</strong> ：<br>存放编译器生成的各种字面常量和符号引用。</p><p>例子：String类在常量池的数据结构类似于HashSet,是唯一的。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/169a02588d5caac4?w=612&h=354&f=png&s=27965" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"abc"</span>; <span class="comment">// 存放在方法区的常量池（字节码常量）唯一</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">// 用了new，所以在堆中创建</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s3); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s3.intern()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注意哦jdk1.8 String常量池搬到了堆中。如果想对<code>intern()</code>了解更多，可以看我的这篇<a href="https://zouxxyy.github.io/2019/03/22/JDK1-8-String%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/#more" target="_blank" rel="noopener">博客</a>。</p><h1 id="HotSpot对象揭秘"><a href="#HotSpot对象揭秘" class="headerlink" title="HotSpot对象揭秘"></a>HotSpot对象揭秘</h1><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>对象创建简单描述：</p><p>new -&gt; 根据常量池中符号看是否需要加载 -&gt; 类加载 -&gt; 分配内存 -&gt; 初始化 -&gt;构造方法</p><p>给对象分配内存的两种方法：</p><ul><li>指针碰撞</li><li>空闲列表</li></ul><p>解决创建对象时线程安全问题两种方法：</p><ul><li>分配内存动作进行同步处理</li><li>TLAB（共享堆中按线程划分的线程私有部分）上分配，它分配完，再同步锁定</li></ul><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>3块区域：</p><ul><li><p>对象头</p><ul><li><p>自身运行时的数据（MarkWord）：HashCode、GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳等</p></li><li><p>类型指针：对象指向它的类元数据的指针，虚拟机可以根据它来确定该对象是哪个类的实例。</p><p>注意如果对象是数组，那么对象头中还有一块用于记录数组长度的数据。</p></li></ul></li><li><p>实例数据</p></li><li><p>对齐填充 ：当实例部分没对齐时，通过对齐填充来补全</p></li></ul><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><ul><li>句柄访问（2级指针）</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/169a038a164fdc67?w=604&h=404&f=png&s=33178" alt><br>可以看出来要到实例数据必须再经过一个指针，这么做到好处是，当对象移动时，我们只需要改变局柄池里的指针，不需要改变reference；缺点是速度慢。</p><ul><li>直接指针</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/169a038c26fd8733?w=602&h=408&f=png&s=28283" alt><br>直接指针顾名思义直接指向实例数据，好处是速度快；缺点就是对象移动要改reference。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《深入理解Java虚拟机（第二版）》第二章的笔记&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8 String常量池详解</title>
    <link href="http://yoursite.com/2019/03/22/JDK1-8-String%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/03/22/JDK1-8-String常量池详解/</id>
    <published>2019-03-22T03:25:08.000Z</published>
    <updated>2019-03-22T03:29:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 JDK1.8 String常量池详解，带图哦</p><a id="more"></a><p><strong>jdk 1.8</strong></p><h1 id="先抛结论"><a href="#先抛结论" class="headerlink" title="先抛结论"></a>先抛结论</h1><h2 id="1-只在常量池上创建常量"><a href="#1-只在常量池上创建常量" class="headerlink" title="1.只在常量池上创建常量"></a>1.只在常量池上创建常量</h2><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a32568b4c1f09?w=531&h=366&f=png&s=15995" alt></p><h2 id="2-只在堆上创建对象"><a href="#2-只在堆上创建对象" class="headerlink" title="2.只在堆上创建对象"></a>2.只在堆上创建对象</h2><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a32d01c0c56b4?w=577&h=389&f=png&s=19131" alt></p><h2 id="3-在堆上创建对象，在常量池上创建常量"><a href="#3-在堆上创建对象，在常量池上创建常量" class="headerlink" title="3.在堆上创建对象，在常量池上创建常量"></a>3.在堆上创建对象，在常量池上创建常量</h2><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a32fd14b320a8?w=553&h=362&f=png&s=18505" alt></p><h2 id="4-在堆上创建对象，在常量池上创建引用"><a href="#4-在堆上创建对象，在常量池上创建引用" class="headerlink" title="4.在堆上创建对象，在常量池上创建引用"></a>4.在堆上创建对象，在常量池上创建引用</h2><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a331a8ed3ecb4?w=561&h=362&f=png&s=20883" alt></p><p>注意：</p><ul><li><p>常量池有两种情况：引用（指针） 或 常量。<strong>如果该位置已经是引用或常量了，之后的操作都不会改变里面的情况！！！</strong></p></li><li><p>调用<code>intern()</code>（jdk1.8）: <strong>如果常量池里是空的，就创建引用（指向堆，参考结论4）；非空，不操作。返回值都是常量池里的内容。</strong></p></li><li><p>堆中可以有任意个相同的字符串，常量池只能有一个（引用 或 常量）。</p></li><li><p>“ “ 和intern() 其实很像。区别就是在常量池为空时，“ ”是把值加进去，intern()是把引用加进去。</p></li></ul><h1 id="根据结论解决例子"><a href="#根据结论解决例子" class="headerlink" title="根据结论解决例子"></a>根据结论解决例子</h1><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"zxy"</span>);    <span class="comment">// 结论3</span></span><br><span class="line">s1.intern(); <span class="comment">// 常量池非空，返回值是常量池里的内容</span></span><br><span class="line">String s2 = <span class="string">"zxy"</span>; <span class="comment">// 常量池非空，返回值是常量池里的内容</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1.intern() == s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a351b50cc98d6?w=569&h=355&f=png&s=18514" alt></p><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"zxy"</span>; <span class="comment">// 加到常量池</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"zxy"</span>); <span class="comment">// 加到堆，常量池有东西所以啥也不干</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">System.out.println(s1 == s2.intern()); <span class="comment">// true 常量池非空，intern返回常量池里的内容</span></span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a35d23404be5b?w=468&h=373&f=png&s=16487" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是 JDK1.8 String常量池详解，带图哦&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>java多线程编程chap5-7</title>
    <link href="http://yoursite.com/2019/03/14/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8Bchap5-7/"/>
    <id>http://yoursite.com/2019/03/14/java多线程编程chap5-7/</id>
    <published>2019-03-14T02:54:58.000Z</published>
    <updated>2019-03-14T02:58:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是《java多线程编程核心技术》第五、六、七章的学习笔记。</p><a id="more"></a><h1 id="定时器-Timer"><a href="#定时器-Timer" class="headerlink" title="定时器 Timer"></a>定时器 Timer</h1><p>Timer类主要负责计划任务的功能</p><p>一些方法：</p><ul><li><code>schedule(TimerTask task, Date time)</code> 在指定的日期执行某一次任务。</li><li><code>schedule(TimerTask task, long delay)</code>    以执行此方法的当前时间为参考时间，在此时间基础上延迟指定的毫秒数后执行一次TimerTask任务</li><li><code>schedule(TimerTask task, long delay, long period)</code>    以执行此方法的当前时间为参考时间，在此时间基础上延迟指定的毫秒数，再以某一间隔时间无限次数地执行某一TimerTask任务</li><li><code>scheduleAtFixedRate(TimerTask task, Date firstTime, long period)</code>    在指定的日期之后，按指定的间隔周期，无限循环的执行某一任务</li></ul><p><code>schedule</code>和<code>scheduleAtFixedRate</code>的异同：</p><p>同：</p><ul><li>多次调用<code>schedule</code>或<code>scheduleAtFixedRate</code>执行多个任务的话，则都是以队列的方式一个一个的被顺序执行。所以不用考虑非线程安全的问题。</li><li>如果任务延时了，那么下一次任务的执行时间都是上一次任务结束的时间（都带<code>period</code>参数时）</li></ul><p>异：</p><ul><li>不延时时，<code>schedule</code>下一次任务的执行时间是上一次任务开始加上<code>period</code>的时间，<code>scheduleAtFixedRate</code>下一次任务的执行时间是上一次任务结束的时间。</li></ul><h1 id="单例模式与多线程"><a href="#单例模式与多线程" class="headerlink" title="单例模式与多线程"></a>单例模式与多线程</h1><p>单例模式是23个设计模式中的一种，本章将它与多线程结合考虑</p><ul><li>立即加载/“饿汉模式”：调用方法前，实例已经被创建了。</li><li>延迟加载/“懒汉模式”：调用get()方法时实例才被创建。最常见的实现办法是在get()方法中进行new实例化。可是在多线程环境中会出问题，即创建多个实例。</li></ul><p>解决方案</p><ul><li><p>声明synchronized关键字，但运行效率非常低</p></li><li><p>同步代码块，但效率也非常低</p></li><li><p>针对某些重要代码单独的同步，效率提升，但是会创建多个实例</p></li><li><p>使用DCL双检查锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyObject myObject = <span class="keyword">new</span> MyObject();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyObject</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyObject <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (MyObject.class) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (myObject == <span class="keyword">null</span>) myObject = <span class="keyword">new</span> MyObject();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用静态内置类</p></li><li><p>使用static代码块</p></li><li><p>使用enum枚举数据类型</p></li></ul><h1 id="拾遗增补"><a href="#拾遗增补" class="headerlink" title="拾遗增补"></a>拾遗增补</h1><p>线程状态：<br><img src="https://user-gold-cdn.xitu.io/2019/3/14/16979f1bac8b4b94?w=843&h=634&f=png&s=182243" alt="方法与线程状态的转换图" title="方法与线程状态的转换图"><br>线程组：</p><ul><li>线程组中可以有线程对象，也可以有线程组，组中还可以有线程。作用是可批量管理线程或线程组对象，有效地对线程或线程组对象进行组织。</li><li>实例化一个线程组时如果不指定所属的线程组，它会自动归属到当前线程对象所属的线程组中。</li></ul><p>线程中出现异常的处理：</p><ul><li><code>setUncaughtExceptionHandler()</code>给指定线程对线设置异常处理器</li><li><code>setDefaultUncaughtExceptionHandler()</code>对指定线程类的所有线程对象设置异常处理器</li></ul><br><br><p><font size="6"><center><strong>完结撒花！</strong></center></font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《java多线程编程核心技术》第五、六、七章的学习笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java多线程编程chap3-4</title>
    <link href="http://yoursite.com/2019/03/13/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8Bchap3-4/"/>
    <id>http://yoursite.com/2019/03/13/java多线程编程chap3-4/</id>
    <published>2019-03-13T03:24:52.000Z</published>
    <updated>2019-03-13T03:25:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是《java多线程编程核心技术》第三、四章的学习笔记。</p><a id="more"></a><h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h2><p><code>wait()</code>和<code>notify()</code>: <code>wait</code>使线程停止运行，<code>notify</code>使停止的线程继续运行。</p><p>注意事项：</p><ul><li><code>wait()</code>自动锁放对象锁；<code>notify()</code>不释放；它们必须存在与同步块中。</li><li>wait 后线程会进入等待池，需要由同一对象的 notify 方法唤醒。</li><li>当线程处于wait状态时，调用<code>interrup()</code>方法会出现异常。</li><li>notify()随机唤醒线程，<code>notifyAll()</code>唤醒全部wait线程.</li><li><code>wait(n)</code>，使线程等待一段时间，如果没被唤醒，超过时间自动唤醒。 </li></ul><p>可以用<code>wait()</code>和<code>notify()</code>实现生产者和消费者</p><ul><li>假死：所有线程都呈WAITING状态。</li><li>原因：notify唤醒的是异类，如“生产者”唤醒“生产者”。</li><li>解决：将<code>notify()</code>改为<code>notifyAll()</code></li></ul><p>通过管道进行线程间通信：一个线程发送数据到输出管道，另一个线程从输入管道中读数据。</p><ul><li>字节流：<code>PipedInputStream</code>和<code>PipedOutputStream</code></li><li>字符流：<code>PipedReader</code>和<code>PipedWriter</code></li></ul><h2 id="方法join的使用"><a href="#方法join的使用" class="headerlink" title="方法join的使用"></a>方法join的使用</h2><p><code>join()</code>：使当前线程堵塞，等待线程对象销毁后，再执行当前线程后面的代码。</p><ul><li><code>join()</code>与<code>interrupt()</code>方法如果彼此遇到，则会出现异常。</li><li><code>join(long)</code>可设定等待的时间。注意：<code>join(long)</code>内部使用<code>wait(long)</code>实现，所以<code>join(long)</code>会<strong>释放锁</strong>；而<code>Thread.sleep(long)</code><strong>不会释放锁</strong>。</li></ul><h2 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h2><ul><li><code>ThreadLocal</code>类：让每个线程可以绑定自己的值</li><li>解决<code>get()</code>返回null的问题：覆盖    <code>initialValue()</code>方法使变量具有初始值。</li><li><code>InheritableThreadLocal</code>类可在子线程中取得父线程继承下来的值。</li><li>还可以对子线程继承下来的值进行修改。</li></ul><h1 id="Lock的使用"><a href="#Lock的使用" class="headerlink" title="Lock的使用"></a>Lock的使用</h1><h2 id="使用ReentrantLock类"><a href="#使用ReentrantLock类" class="headerlink" title="使用ReentrantLock类"></a>使用ReentrantLock类</h2><p>基本用法：</p><ul><li>同步： <code>lock()</code> 让线程持有了“对象监视器”，和synchronized一样，线程之间还是顺序执行的。</li><li>等待/通知： <code>condition.await()</code> 等待；<code>condition.siganl()</code>通知。注意调用<code>condition.await()</code>前须先调用<code>lock.lock()</code>。它比wait更灵活，因为它可以用不同的<code>condition</code>对象实现通知部分线程。</li></ul><p>公平锁和非公平锁</p><ul><li>公平锁： <code>new ReentranLock(true)</code> 获取锁是先进先得的</li><li>非公平锁： <code>new ReentranLock(false)</code> 获取锁是随机的</li></ul><p>一些方法：</p><ul><li><code>int getHoldCount()</code>    查询当前线程保持此锁定的个数，也就是调用lock()方法的次数。</li><li><code>int getQueueLength()</code>    返回正在等待获取此锁定的线程估计数</li><li><code>int getWaitQueueLength(Condition condition)</code>    返回等待与此锁定相关的给定条件Conditon的线程估计数</li><li><code>boolean hasQueueThread(Thread thread)</code>    查询指定的线程是否正在等待获取此锁定</li><li><code>boolean hasQueueThreads()</code>    查询是否有线程正在等待获取此锁定</li><li><code>boolean hasWaiters(Condition)</code>        查询是否有线程正在等待与此锁定有关的condition条件</li><li><code>boolean isFair()</code>    判断是不是公平锁</li><li><code>boolean isHeldByCurrentThread()</code>        查询当前线程是否保持此锁定</li><li><code>boolean isLocked()</code>    查询此锁定是否由任意线程保持</li><li><code>void lockInterruptibly()</code>    如果当前线程未被中断，则获取锁定，如果已经被中断则出现异常</li><li><code>boolean tryLock()</code>    仅在调用时锁定未被另一个线程保持的情况下，才获取该锁定</li><li><code>boolean tryLock(long timeout,TimeUnit unit)</code>    如果锁定在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁定</li><li><code>void awaitUninterruptibly()</code>    await状态时调用thread.interrupt()不会报错</li></ul><h2 id="使用ReentrantReadWriteLock类"><a href="#使用ReentrantReadWriteLock类" class="headerlink" title="使用ReentrantReadWriteLock类"></a>使用ReentrantReadWriteLock类</h2><p><code>ReentrantLock</code>类完全互斥，即同一时间只有一个线程可执行lock后面的任务。</p><p><code>ReentrantReadWriteLock</code>特点：</p><ul><li>读读共享</li><li>写写互斥</li><li>写读互斥</li><li>读写互斥</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《java多线程编程核心技术》第三、四章的学习笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java多线程编程chap1-2</title>
    <link href="http://yoursite.com/2019/03/11/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8Bchap1-2/"/>
    <id>http://yoursite.com/2019/03/11/java多线程编程chap1-2/</id>
    <published>2019-03-11T08:24:39.000Z</published>
    <updated>2019-03-11T08:27:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是《java多线程编程核心技术》第一、二章的学习笔记。</p><a id="more"></a><h1 id="第一章：Java多线程技能"><a href="#第一章：Java多线程技能" class="headerlink" title="第一章：Java多线程技能"></a>第一章：Java多线程技能</h1><h2 id="使用多线程"><a href="#使用多线程" class="headerlink" title="使用多线程"></a>使用多线程</h2><ul><li>实现多线程有两种方式：继承<code>Thread</code>类、实现<code>Runnable</code>接口</li><li><code>Thread.java</code>中的<code>start()</code>方法是异步执行，<code>thread.run</code>是同步；而且<code>start()</code>方法的顺序不代表线程启动的顺序，它是随机的。</li><li>在方法前加<code>synchronized</code>可以让线程安全。</li></ul><h2 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h2><ul><li><code>currentThread()</code> 返回代码段正在被哪个线程调用</li><li><code>isAlive()</code> 判断当前线程是否处于活动状态</li><li><code>sleep()</code> 让线程休眠</li><li><code>getID()</code> 获得线程的唯一标志</li><li><code>yield()</code> 让当前线程放弃cpu资源，但时间不确定</li></ul><h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><p>方式：</p><ul><li>使用退出标识，使线程正常退出，也就是当run方法完成后线程退出</li><li>使用interrupt方法中断线程</li></ul><p>第二种方式要注意：</p><ul><li><code>interrupt()</code> 实例方法，让线程中断，再用异常法检测中断使程序停止</li><li><code>interrupted()</code>是静态方法，测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false的功能。</li><li><code>isInterrupted()</code>是实例方法，测试Thread对象是否已经是中断状态，但不清除状态标志。</li><li>如果在sleep状态下停止某一线程，会进入catch语句（不需要判断是否中断），并且清除停止状态，使它变为false.</li></ul><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p><code>getPriority()</code>查看优先级，<code>setPriority()</code>设置优先级，有1～10级<br>线程优先级的特点：</p><ul><li>继承性: 如过线程A启动线程B，则B和A优先级一样</li><li>规则性: CPU尽量倾向于把资源优先级高的线程</li><li>随机性: 优先级不等同于执行顺序，优先级较高的不一定先执行完</li></ul><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>Java的线程分为两种：User Thread(用户线程)、Daemon Thread(守护线程)。</p><p>当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。Daemon作用是为其他线程提供便利服务，守护线程最典型的应用就是GC(垃圾回收器)，它就是一个很称职的守护者。</p><h1 id="第二章：对象及变量的并发访问"><a href="#第二章：对象及变量的并发访问" class="headerlink" title="第二章：对象及变量的并发访问"></a>第二章：对象及变量的并发访问</h1><h2 id="synchronized同步方法"><a href="#synchronized同步方法" class="headerlink" title="synchronized同步方法"></a>synchronized同步方法</h2><ul><li>方法内的变量为线程安全，而实例变量非线程安全。</li><li>不同线程调用<strong>同一对象</strong>里的<strong>synchronized</strong>方法时，是同步的(排队进行)。也就是必须等线程执行完<code>synchronized</code>方法时，下一线程才能执行<code>synchronized</code>方法。</li><li>可重入锁: 一个线程得到对象锁后，再次请求此对象锁时是可以得到该对象的锁的。子类也可以调用父类的同步方法。</li><li>出现异常，锁自动释放</li><li>子类方法不会继承<code>synchronized</code>关键字，需要手动在子类方法中加上。</li></ul><h2 id="synchronized同步语句块"><a href="#synchronized同步语句块" class="headerlink" title="synchronized同步语句块"></a>synchronized同步语句块</h2><ul><li>多个线程处理同一个对象的<code>synchronized(this)</code>同步语句块时，只能排队执行</li><li>同一个对象的<code>synchronized(this)</code>和<code>synchronized</code>同步方法之间也是同步的。即<strong>同一时间只有一个线程可执行synchronized代码块或方法中的代码</strong></li><li><code>synchronized(非this对象x)</code>，是将x对象作为“对象监视器”<ul><li>当多个线程同时执行<code>synchronized(x){}</code>同步代码块时呈同步效果</li><li>当其他线程执行x对象中<code>synchronizd</code>同步方法时呈同步效果</li><li>当其他线程执行x对象方法里的<code>synchronized(this)</code>代码块时呈同步效果</li></ul></li><li>静态同步    <code>synchronized</code>方法与<code>synchronized(class)</code>代码块是对Class类进行持锁。</li><li>当线程在等带根本不可能被释放的锁是，就会出现死锁。</li><li>如果同时持有相同的锁对象，线程之间就是同步的。注意对象的属性改变，运行结果还是同步的。</li></ul><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p><code>volatile</code>: 强制的从公共内存进行取值,而不是从线程私有数据栈中取得变量的值。可以使变量在多个线程间可见，但缺点是不支持原子性。</p><p><code>synchronized</code>和<code>volatile</code>比较:</p><ul><li>关键字volatile是线程同步的轻量级实现，所以volatile性能比synchronized好，并且volatile只能修饰变量，而synchronized可修饰方法和代码块。</li><li>多线程访问volatile不会发生阻塞，而synchronized会出现阻塞</li><li>volatile能保证数据可见性，不保证原子性;synchronized可以保证原子性，也可以间接保证可见性，因为synchronized会将私有内存和公共内存中的数据做同步。</li><li>volatile解决的是变量在多个线程间的可见性，synchronized解决的是多个线程访问资源的同步性（互斥加可见）。</li></ul><p>原子类:</p><p>如<code>AtomicBoolean</code>，<code>AtomicInteger</code>，<code>AtomicLong</code>等。一个原子类型就是一个原子操作可用的类型，可在没有锁的情况下做到线程安全。但原子类的方法间的调用却不是原子的，需要用同步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《java多线程编程核心技术》第一、二章的学习笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>corejava基础知识(6)-视图</title>
    <link href="http://yoursite.com/2019/03/07/corejava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-6-%E8%A7%86%E5%9B%BE/"/>
    <id>http://yoursite.com/2019/03/07/corejava基础知识-6-视图/</id>
    <published>2019-03-07T08:01:12.000Z</published>
    <updated>2019-03-07T08:15:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 java 视图的总结。</p><a id="more"></a><h1 id="集合包装器视图"><a href="#集合包装器视图" class="headerlink" title="集合包装器视图"></a>集合包装器视图</h1><p><code>Array</code>包装成<code>List</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Card[] cardArray = <span class="keyword">new</span> Card[<span class="number">52</span>];</span><br><span class="line">List&lt;Card&gt; cardList = Arrays.asList(cardArray);</span><br></pre></td></tr></table></figure><p><code>Arrays</code>类的静态方法 <code>asList</code> 将返回一个包装了 <code>List</code> 的包装器。 注意返回的是<strong>视图对象</strong>，它只能使用<code>get</code> ，<code>set</code>方法。</p><p><code>Map</code>包装成<code>Set</code>:</p><ul><li><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code>返回<code>Map.Entry</code>对象的一个集视图。</li><li><code>Set&lt;K&gt; keySet()</code> 返回映射中所有键的一个集视图。</li><li><code>Col1ection&lt;V&gt; values()</code> 返回映射中所有值的一个集合视图。</li></ul><p>可以从集视图中删除元素，映射中对应的键和值也会被删除， 不过不能增加任何元素。</p><h1 id="子范围视图"><a href="#子范围视图" class="headerlink" title="子范围视图"></a>子范围视图</h1><p>可以为集合建立子范围视图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List group2 =staff.subList(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 列表的子范围</span></span><br><span class="line"></span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E from, E to)</span></span>; <span class="comment">//有序集根据排序顺序建立子视图</span></span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E to)</span></span>;</span><br><span class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E from)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">subMap</span><span class="params">(K from, K to)</span></span>; <span class="comment">//和有序集同理</span></span><br><span class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">headMap</span><span class="params">(K to)</span></span>;</span><br><span class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">tailMap</span><span class="params">(K from)</span></span>;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>范围是左闭右开</li><li>可以将任何操作应用于子范围， 并且能够自动地反映到原范围。</li><li>对顺序集合对子集合添加元素时，新元素必须在子范围内</li></ul><h1 id="不可修改的视图"><a href="#不可修改的视图" class="headerlink" title="不可修改的视图"></a>不可修改的视图</h1><p>顾名思义生成不可修改的视图，如果发现试图对集合进行修改，就抛出一个异常。当然原对象肯定还是可以修改的。</p><p>例如：生成一个不可修改的Map视图:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;String, Integer&gt; scores = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">...</span><br><span class="line">Map&lt;String, Integer&gt; umMap = Collections.synchronizedSortedMap(scores);</span><br></pre></td></tr></table></figure><h1 id="同步视图"><a href="#同步视图" class="headerlink" title="同步视图"></a>同步视图</h1><p>类库的设计者使用视图机制来确保常规集合的线程安全，而不是实现线程安全的集合类。 </p><p>例如：新建一个线程安全的Map:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Employee〉map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, Employee&gt;());</span><br></pre></td></tr></table></figure><h1 id="受查视图"><a href="#受查视图" class="headerlink" title="受查视图"></a>受查视图</h1><p>受查视图可以查出 将错误类型的元素混人泛型集合 这种情况。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; safestrings = Collections.checkedList(strings，String,<span class="class"><span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>当加入错误类型时，会得到错误报告。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 java 视图的总结。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>corejava基础知识(5)-集合</title>
    <link href="http://yoursite.com/2019/03/07/corejava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-5-%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2019/03/07/corejava基础知识-5-集合/</id>
    <published>2019-03-07T03:29:01.000Z</published>
    <updated>2019-03-07T03:51:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 java 集合的总结。书的思路是将接口与实现分开讲；然后从父讲起，再讲子对父的提升。我觉得这种方式很好理解加记忆，所以本文也是这样整理的。</p><a id="more"></a><h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><p>主要思路是让<strong>接口与实现分离</strong></p><p>集合框架的接口：两个基本接口 <code>Collection</code> 和 <code>Map</code></p><p><img src="corejava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-5-%E9%9B%86%E5%90%88/interface.png" alt="集合框架的接口" title="集合框架的接口"></p><p>集合框架的类：</p><p><img src="corejava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-5-%E9%9B%86%E5%90%88/me.png" alt="集合框架的类" title="集合类的解释"></p><p><img src="corejava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-5-%E9%9B%86%E5%90%88/shixian.png" alt="集合框架的类" title="集合框架的类"></p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="两个基本接口：Collection-和-Map"><a href="#两个基本接口：Collection-和-Map" class="headerlink" title="两个基本接口：Collection 和 Map"></a>两个基本接口：<code>Collection</code> 和 <code>Map</code></h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>以下是<code>Collection</code>接口内的一些方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">interface</span> <span class="title">class</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">Collection</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> java.util.<span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(java.util.Collection)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(java.util.Collection)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(java.util.Collection)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(java.util.Collection)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(java.util.function.Predicate)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来就是 <strong>大小，加，删，是否含某个元素，是否空 等等</strong>，这些集合最基础的功能</p><p><code>Collection</code>中有<code>Iterator</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">interface</span> <span class="title">class</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">Iterator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> java.lang.<span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(java.util.function.Consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>以下是<code>Map</code>接口内的一些方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">interface</span> <span class="title">class</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">Map</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(java.lang.Object, java.lang.Object)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> java.lang.<span class="function">Object <span class="title">get</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> java.lang.<span class="function">Object <span class="title">put</span><span class="params">(java.lang.Object, java.lang.Object)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(java.lang.Object, java.lang.Object, java.lang.Object)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(java.util.function.BiFunction)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(java.util.Map)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">putIfAbsent</span><span class="params">(java.lang.Object, java.lang.Object)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> java.util.<span class="function">Set <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">getOrDefault</span><span class="params">(java.lang.Object, java.lang.Object)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(java.util.function.BiConsumer)</span></span>;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来就是 <strong>大小，加映射，删映射，用键查值，是否空</strong> 等等，这些映射最基础的功能。还有些视图的部分，下篇文章具体讲</p><h2 id="Collection的子接口"><a href="#Collection的子接口" class="headerlink" title="Collection的子接口"></a>Collection的子接口</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>有序集合，新加支持随机访问功能：</p><ul><li>add(n, 元素)</li><li>remove(n)</li><li>get(n)</li><li>set(n, 元素)</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ol><li>元素不重复，所以要适当的定义<code>equals</code>方法；</li><li>子接口<code>SortedSet</code>，故名思义是排好序的，所以要适当的定义比较器</li><li><code>SortedSet</code>的子接口<code>NavigableSet</code>中设计了一些搜素，遍历的方法</li></ol><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><ol><li>入队尾，出对头</li><li>子接口<code>Qeque</code>双端队列，两头都可以出入</li></ol><h2 id="Map的子接口"><a href="#Map的子接口" class="headerlink" title="Map的子接口"></a>Map的子接口</h2><p>其实和<code>Set</code>差不多</p><ol><li>子接口<code>SortedMap</code>，故名思义是排好序的，所以要适当的定义比较器</li><li><code>SortedMap</code>的子接口<code>NavigableMap</code>中设计了一些搜素，遍历的方法</li></ol><h1 id="对接口的实现"><a href="#对接口的实现" class="headerlink" title="对接口的实现"></a>对接口的实现</h1><h2 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h2><h3 id="LinkedList-链表"><a href="#LinkedList-链表" class="headerlink" title="LinkedList(链表)"></a>LinkedList(链表)</h3><p>java中的链表都是双向的（有前驱后驱）。重点讲下它的迭代器<code>ListIterator</code></p><ul><li>初始位置： |ABCD</li><li><code>iter.next</code>:  A|BCD</li><li><code>iter.previous</code>: |ABCD</li><li><code>iter.add</code> : 把元素加到光标<code>|</code>之前，注意是之前</li><li><code>iter.remove</code>必须在<code>it.next</code>或<code>it.previous</code>使用之后使用，把光标<strong>经过</strong>的元素删除</li></ul><p>链表使用注意：</p><ul><li>使用链表是可以减少在列表中间插入删除元素所付出的代价。</li><li>避免使用以整数索引链表中的位置，这样效率很低</li></ul><h3 id="ArrayList-数组列表"><a href="#ArrayList-数组列表" class="headerlink" title="ArrayList(数组列表)"></a>ArrayList(数组列表)</h3><p><code>ArrayList</code>： 动态泛型数组列表，可以自动调节数组容量。当需要随机访问时使用它效率更高，不用链表。<br>讲下<code>capacity</code>和<code>size</code>的区别：</p><ul><li><code>new ArrayList&lt;&gt;(100)</code>    100 是<code>capacity</code>，是初始容量，如果实际size超过它，容量会自动增加</li><li><code>array.size()</code>返回的是数组列表内元素实际的个数。</li></ul><p>p.s. 这和c++的 <code>vector</code> 很像</p><h2 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h2><h3 id="HashSet-散列集"><a href="#HashSet-散列集" class="headerlink" title="HashSet(散列集)"></a>HashSet(散列集)</h3><p><img src="corejava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-5-%E9%9B%86%E5%90%88/hash.png" alt="散列表" title="散列表"></p><ul><li><code>HashSet</code>: 基于散列表的Set，内部用链表数组实现。初始化时可以指定容量和装填因子。</li><li>由于HashSet访问是随机的，所以当不需要关心集合中的顺序时才使用它。</li><li>子类<code>LinkedHashSet</code>，里面的元素之间是双向链表，迭代器是按<strong>插入顺序</strong>进行访问的。</li></ul><h3 id="TreeSet-树集"><a href="#TreeSet-树集" class="headerlink" title="TreeSet(树集)"></a>TreeSet(树集)</h3><p>-<code>TreeSet</code>: 实现<code>SortedSet</code>接口，内部基于<strong>红黑树</strong>。由于是有顺序的，所以用户一般要自定义比较器。迭代器是按<strong>排序顺序</strong>进行访问的。</p><ul><li>当不需要顺序时，用<code>HashSet</code>，因为它更快。</li><li>可以实现升级版<code>NavigableSet</code>接口，higher(v),lower(v),pollFirst(),pollLast(),反向迭代 等等。</li></ul><h2 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h2><p>一般用它的升级版<code>Deque</code>，而<code>Deque</code>可以由<code>ArrayDeque</code>和<code>LinkedList</code>实现。下面主要介绍<code>PriorityQueue</code></p><h3 id="PriorityQueue-优先级队列"><a href="#PriorityQueue-优先级队列" class="headerlink" title="PriorityQueue(优先级队列)"></a>PriorityQueue(优先级队列)</h3><ul><li><code>PriorityQueue</code>：优先级队列，内部基于<strong>堆</strong>（heap）。</li><li>按任意顺序插入，却总是按排序顺序输出<strong>最小值</strong>。</li><li><code>PriorityQueue&lt;Type&gt; pq = new PriorityQueue();</code>，从左边可以看出这货是类。</li></ul><h2 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul><li>顾名思义和<code>HashSet</code>差不多，只不过是对建进行散列。</li><li>子类<code>LinkedHashMap</code>，注意链表散射映射，迭代器是按<strong>访问顺序</strong>进行访问的。每次调用 get 或 put, 受到影响的条目将从当前的位置删除，并放到条目链表的尾部。</li></ul><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ul><li>顾名思义和<code>HashMap</code>差不多，只不过是对建进行<strong>红黑树</strong>排序。</li><li>同样 当不需要顺序时，用<code>HashMap</code>，因为它更快.</li></ul><p>一些技巧：</p><ul><li>遍历Map：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scores.forEach((k, v) -&gt; <span class="comment">// 访问 k, v 的最快方法</span></span><br><span class="line">        System.out.println(<span class="string">"key="</span> + k + <span class="string">", value"</span> + v));</span><br></pre></td></tr></table></figure><ul><li>用 Map 计数：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scores.put(<span class="string">"Jack"</span>, scores.getOrDefault(<span class="string">"Jack"</span>, <span class="number">0</span>) + <span class="number">1</span>); <span class="comment">// 方法1</span></span><br><span class="line">scores.merge(<span class="string">"Jack"</span>, <span class="number">1</span>, Integer::sum); <span class="comment">// 方法2</span></span><br></pre></td></tr></table></figure><h3 id="WeekHashMap"><a href="#WeekHashMap" class="headerlink" title="WeekHashMap"></a>WeekHashMap</h3><p>弱散列映射：当对键的唯一引用来自散列条目时，这一数据结构将与垃圾回收器协同工作一起删除键 / 值对。也就是当某个值没用了它会被自动回收。</p><h3 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h3><ul><li><code>IdentityHashMap</code> 中 键的散列值 不是用 hashCode 函数计算的，而是用 <code>System.identityHashCode</code> 方法计算的（<code>Object.hashCode</code>方法根据对象的内存地址来计算散列码时所使用的方式）。</li><li>所以，在对两个对象进行比较时，IdentityHashMap 使用 == , 而不使用equal。也就是不同的键对象，即使内容相同，也被视为是不同的对象。</li><li>在实现对象遍历算法 (如对象串行化)时，可以它用来跟踪每个对象的遍历状况。</li></ul><h1 id="遗留的集合"><a href="#遗留的集合" class="headerlink" title="遗留的集合"></a>遗留的集合</h1><p>看看就好，遇到时再查书</p><p><img src="corejava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-5-%E9%9B%86%E5%90%88/yiliu.png" alt="遗留集合" title="遗留集合"></p><p>本文示例代码：<a href="https://github.com/Zouxxyy/java-learning/tree/master/corejava-learning/src/com/zouxxyy/corejava/chap9" title="github" target="_blank" rel="noopener">github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 java 集合的总结。书的思路是将接口与实现分开讲；然后从父讲起，再讲子对父的提升。我觉得这种方式很好理解加记忆，所以本文也是这样整理的。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>corejava基础知识(4)-通配符</title>
    <link href="http://yoursite.com/2019/03/05/corejava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(4)-%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
    <id>http://yoursite.com/2019/03/05/corejava基础知识(4)-通配符/</id>
    <published>2019-03-05T08:00:49.000Z</published>
    <updated>2019-03-05T08:20:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 java 通配符的总结</p><a id="more"></a><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><h2 id="泛型的局限性与漏洞"><a href="#泛型的局限性与漏洞" class="headerlink" title="泛型的局限性与漏洞"></a>泛型的局限性与漏洞</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Employee&gt; employeePair= <span class="keyword">new</span> Pair&lt;&gt;(<span class="keyword">new</span> Employee(<span class="string">"员工1"</span>), <span class="keyword">new</span> Employee(<span class="string">"员工2"</span>));</span><br><span class="line">Pair&lt;Manager&gt; managerPair= <span class="keyword">new</span> Pair&lt;&gt;(<span class="keyword">new</span> Manager(<span class="string">"经理1"</span>, <span class="number">100</span>), <span class="keyword">new</span> Manager(<span class="string">"经理2"</span>, <span class="number">200</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试1</span></span><br><span class="line"><span class="comment">//employeePair = managerPair; //错误， `Pair&lt;S&gt;`和`Pair&lt;T&gt;`没有什么联系。</span></span><br><span class="line"><span class="comment">//managerPair = employeePair // 错误， `Pair&lt;S&gt;`和`Pair&lt;T&gt;`没有什么联系。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试2</span></span><br><span class="line">Pair pair = employeePair; <span class="comment">// 泛型与原始内容兼容，但是，看下面</span></span><br><span class="line"><span class="comment">//pair.getFirs t().getName(); // error, 是Employee类，但是不能调用方法!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试3</span></span><br><span class="line">employeePair.setFirst(<span class="keyword">new</span> Manager(<span class="string">"经理3"</span>, <span class="number">300</span>)); <span class="comment">// employeePair里经理竟然和员工组成一对！</span></span><br><span class="line">System.out.println(employeePair.getFirst().getName()); <span class="comment">// 经理3</span></span><br><span class="line">System.out.println(employeePair.getSecond().getName()); <span class="comment">// 员工2</span></span><br><span class="line"><span class="comment">// System.out.println(((employeePair.getFirst())).getSalary()); // error</span></span><br><span class="line">System.out.println(((Manager)(employeePair.getFirst())).getSalary()); <span class="comment">// 300.0 ，添加类强制类型转换后可以调用，这与普通类继承规则一样</span></span><br></pre></td></tr></table></figure><p>完整代码：<a href="https://github.com/Zouxxyy/java-learning/blob/master/corejava-learning/src/com/zouxxyy/corejava/chap8/inherit/testInherit.java" title="github" target="_blank" rel="noopener">继承示例</a></p><ol><li>无论 S 和 T 有什么关系，<code>Pair&lt;S&gt;</code>和<code>Pair&lt;T&gt;</code>没有什么联系。</li><li>泛型与原始内容兼容，但是原始内容里的类型参数这个对象无法调用方法</li><li>泛型里的类型参数可以继承，和类的继承规则一样</li></ol><h2 id="extends-Object（上边界限定通配符）"><a href="#extends-Object（上边界限定通配符）" class="headerlink" title="?  extends Object（上边界限定通配符）"></a>?  extends Object（上边界限定通配符）</h2><p>可以看出来原始泛型遇上继承时会有些漏洞，比如会出现经理员工在同一<code>Pair</code>的情况。于是Java专家引入了类型通配符 <code>?</code></p><p>我们把刚刚的第一行改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;? extends Employee&gt; employeePair= <span class="keyword">new</span> Pair&lt;&gt;(<span class="keyword">new</span> Employee(<span class="string">"员工1"</span>), <span class="keyword">new</span> Employee(<span class="string">"员工2"</span>));</span><br></pre></td></tr></table></figure><p>此时，如果再向里面添加<code>Manager</code>时就会发生错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">employeePair.setFirst(<span class="keyword">new</span> Manager(<span class="string">"经理3"</span>, <span class="number">300</span>)); <span class="comment">// 错误</span></span><br><span class="line">employeePair.setFirst(<span class="keyword">new</span> Employee(<span class="string">"员工"</span>)); <span class="comment">// 错误，甚至添加员工都不行</span></span><br></pre></td></tr></table></figure><p>但是访问可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee employee = employeePair.getFirst(); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先永远记住<strong>只能超类接收子类！！！反过来不行！！！</strong>（这个可以解释下面的一切）</p><p><strong>类型擦除</strong> 后 <code>Pair&lt;? extends Employee&gt;</code> 的方法有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? <span class="function">extends Employee <span class="title">getFirst</span><span class="params">()</span> </span>&#123;...&#125; <span class="comment">// 访问器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(? extends Employee)</span> </span>&#123;...&#125; <span class="comment">// 更改器</span></span><br></pre></td></tr></table></figure><ul><li>访问器的返回值是<code>? extends Employee</code> ，可以用子类<code>Employee</code>接收</li><li>更改器的接收值是<code>? extends Employee</code> ，极端情况是<code>Employee</code>的<code>最下面的子类</code>，而<code>最下面的子类</code>只能接收更下面的子类（无），因此 <strong>拒绝接收任何特定的类型！</strong></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>简单说就是：<br>可以 <code>Employee</code> &lt;– <code>? extends Employee</code> ，但是反过来不行！</p><p>所以这就是大家说的使用<code>? extends Object</code> 可以 <strong>安全的访问泛型对象</strong>。我的理解核心是：如果<code>T</code>作为<strong>返回值</strong>，用<code>? extends Object</code>更安全。</p><h2 id="super-Object（下边界限定通配符）"><a href="#super-Object（下边界限定通配符）" class="headerlink" title="?  super Object（下边界限定通配符）"></a>?  super Object（下边界限定通配符）</h2><p>这个和上面正好相反，更改器能用，访问器不能用。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? <span class="function"><span class="keyword">super</span> Employee <span class="title">getFirst</span><span class="params">()</span> </span>&#123;...&#125; <span class="comment">// 访问器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(? <span class="keyword">super</span> Employee)</span> </span>&#123;...&#125; <span class="comment">// 更改器</span></span><br></pre></td></tr></table></figure><ul><li>访问器的返回值是<code>? super Employee</code> ，极端情况是<code>Object</code>，只能用<code>Object</code>接收</li><li>更改器的接收值是<code>? super Employee</code> ，可以接收<code>Employee 和 它的子类</code></li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>简单说就是：<br>可以 <code>? super Employee</code> &lt;– <code>Employee</code> ，但是反过来不行！</p><p>所以这就是大家说的使用<code>? super Object</code> 可以 <strong>安全的更改泛型对象</strong>。我的理解核心是：如果<code>T</code>作为<strong>方法参数</strong>，用<code>? super Object</code>更安全。</p><h3 id="共同特点"><a href="#共同特点" class="headerlink" title="共同特点"></a>共同特点</h3><p>右边的值传给左边接收：</p><p><code>? super Employee</code> &lt;– <code>Employee</code> &lt;– <code>? extends Employee</code></p><p>是不是完全符合 <strong>只能超类接收子类</strong>，知道原理记起来就简单。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>举书上的一个例子作为练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span> <span class="comment">//计算T[]的最小值</span></span></span><br></pre></td></tr></table></figure><p>理解：</p><ul><li><code>T extends...</code> 好理解，就是<code>T</code>要实现后面的接口。</li><li>实现<code>Comparable&lt;? super T&gt;</code> 接口里的方法<code>int compareTo(? super T)</code>；此时<code>类型</code>作为 方法参数，所以用<code>? super</code>更安全。</li></ul><h2 id="？（无限定通配符）"><a href="#？（无限定通配符）" class="headerlink" title="？（无限定通配符）"></a>？（无限定通配符）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? getFirst() &#123;...&#125; <span class="comment">// 访问器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(?)</span> </span>&#123;...&#125; <span class="comment">// 更改器</span></span><br></pre></td></tr></table></figure><ul><li>访问器只能用<code>Object</code>接收</li><li>更改器不能用</li></ul><p>可以用任意<code>Object</code>对象调用原始 <code>Pair</code>类的<code>setObject</code>方法，说白了就是什么类型都能<br>作为泛型方法的方法参数，但就是不能有返回值。</p><h2 id="通配符捕获"><a href="#通配符捕获" class="headerlink" title="通配符捕获"></a>通配符捕获</h2><p>由于通配符不能作为类型变量，所以必要时可以用一个辅助的泛型方法。</p><p>第一步：辅助泛型方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(Pair&lt;T&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t = p.getFirst();</span><br><span class="line">    p.setFirst(p.getSecond());</span><br><span class="line">    p.setSecond(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：通配符捕获</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Pair&lt;?&gt; p)</span></span>&#123; swapHelper(p); &#125;</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>完整代码：<a href="https://github.com/Zouxxyy/java-learning/blob/master/corejava-learning/src/com/zouxxyy/corejava/chap8/pair3/PairTest3.java" title="github" target="_blank" rel="noopener">通配符示例</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 java 通配符的总结&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>corejava基础知识(3)-泛型</title>
    <link href="http://yoursite.com/2019/03/05/corejava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(3)-%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/05/corejava基础知识(3)-泛型/</id>
    <published>2019-03-05T07:55:39.000Z</published>
    <updated>2019-03-05T07:59:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 java 泛型的总结</p><a id="more"></a><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型类与方法的一般格式"><a href="#泛型类与方法的一般格式" class="headerlink" title="泛型类与方法的一般格式"></a>泛型类与方法的一般格式</h2><p>泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first; </span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123; first = <span class="keyword">null</span> ; second = <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123; <span class="keyword">this</span>.first = first; <span class="keyword">this</span>.second = second; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> first; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> second; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T newValue)</span> </span>&#123; first = newValue; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T newValue)</span> </span>&#123; second = newValue; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T... a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是在普通类定义的泛型方法，调用时：</p><p><code>String middle = ArrayAlg.&lt;String&gt;getMiddle(&quot;]ohnM, &quot;Q.n, &quot;Public&quot;);</code></p><p>术语：</p><ul><li><code>ArrayList&lt;E&gt;</code> – 泛型类型</li><li><code>ArrayList</code> – 原始类型</li><li><code>E</code> – 类型参数(变量)</li><li><code>&lt;&gt;</code> – 读作”typeof”</li><li><code>ArrayList&lt;Integer&gt;</code> – 参数化的类型</li><li><code>Integer</code> – 实际类型参数</li></ul><h2 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h2><p>我们可以对类型变量加以约束，毕竟我们很难适用每种泛型。可以通过对类型变量 T 设置限定(bound) 实现这一点，格式如下：</p><p><code>&lt;T extends BoundingType&gt;</code></p><p>BoundingType 可以是</p><ul><li><strong>类</strong>：T 是它的子类型(subtype)</li><li><strong>接口</strong>： T 是实现了该接口的类</li></ul><p>可以有多个接口，当然至多有一个类，用 “&amp;” 分隔。</p><p><strong>ps: 由于类型擦除机制，为了提高效率，应该将标签(tagging) 接口 (即没有方法的接口)放在边界列表的末尾。</strong></p><h2 id="泛型转化的内部"><a href="#泛型转化的内部" class="headerlink" title="泛型转化的内部"></a>泛型转化的内部</h2><ul><li>虚拟机中没有泛型， 只有普通的类和方法；所有的类型参数都用它们的限定类型替换。 </li><li>编译器在调用泛型方法时会自动插入强制类型转换。</li><li>桥方法被合成来保持多态。 </li></ul><h2 id="约束与局限性"><a href="#约束与局限性" class="headerlink" title="约束与局限性"></a>约束与局限性</h2><ul><li><strong>不能用基本类型实例化类型参数</strong></li></ul><p>即没有<code>Pair&lt;double&gt;</code>，只有<code>Pair&lt;Double&gt;</code>。原因是类型擦出后，Object不能存储double值，毕竟它不是对象</p><ul><li><strong>运行时类型查询只适用于原始类型</strong></li></ul><p>所有的类型查询只产生原始类型，例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; stringPair = ...;</span><br><span class="line">Pair&lt;Employee&gt; employeePair = ...;</span><br><span class="line"><span class="keyword">if</span>(stringPir.getClass() == employeePair.getClass()) <span class="comment">// they are equal</span></span><br></pre></td></tr></table></figure><ul><li><strong>不能创建参数化类型的数组</strong></li></ul><p><code>Pair&lt;String&gt;[] table</code>是错的；</p><p>只能使用AllayList： <code>ArrayList&lt;Pair&lt;String&gt;&gt; table</code></p><ul><li><strong>Varargs警告</strong></li></ul><p>向参数个数可变的方法传递一个泛型类型的实例时，为了调用这个方法，Java 虚拟机必须建立一个参数化类型的数组，可是这违反了前一个规则。</p><p>我们可以用 @SafeVarargs 直接标注该方法，这样就能正常运行。</p><ul><li><strong>不能实例化类型变量</strong></li></ul><p>例如：</p><p><code>public Pair() { first = new T(); second = new T(); } // Error</code></p><ul><li><strong>不能构造泛型数组</strong></li></ul><ul><li><strong>泛型类的静态上下文中类型变量无效</strong></li></ul><p>也就是不能在静态域或方法中引用类型变量。</p><ul><li><strong>不能抛出或捕获泛型类的实例</strong></li><li><strong>可以消除对受查异常的检查</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 java 泛型的总结&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>corejava基础知识(2)-接口和lambda表达式</title>
    <link href="http://yoursite.com/2019/03/05/corejava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(2)-%E6%8E%A5%E5%8F%A3%E5%92%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/05/corejava基础知识(2)-接口和lambda表达式/</id>
    <published>2019-03-05T07:45:25.000Z</published>
    <updated>2019-03-05T08:52:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 java 接口和lambda表达式的总结</p><a id="more"></a><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="接口概念"><a href="#接口概念" class="headerlink" title="接口概念"></a>接口概念</h2><p>  接口是对类的一组需求的描述，类遵从特定的描述，实现这项服务。<br>  例如：<br>  这是Camprable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在类中实现这一接口:</p><ol><li>将类声明为实现给定的接口</li><li>对接口中<strong>所有</strong>方法进行定义</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(salary, other.salary);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h2><ul><li>接口不是类，不能用new实例化一个接口，可是能声明接口变量，然后再引用实现了该接口的类对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Compararble x;</span><br><span class="line">x = <span class="keyword">new</span> Employee(...); <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><p>解释：</p><p>可能会问这样的接口变量有啥用呢？？举个定时器的例子，Timer函数 需要接收 一个操作函数 ，但是我们不能直接传函数进去，所以我们把接口变量（引用实现了该接口的类）传进去。同时我们可以发现接口里的方法<strong>不是静态方法</strong>，因为我们需要先新建对象。</p><p>当然 javase8 中可以用 <strong>lambda表达式</strong> 传函数，见下文 lambda 表达式</p><ul><li>检查某对象是否实现某接口</li></ul><p><code>if(anObject instanceof Comparable) {...}</code></p><ul><li>接口也可以扩展</li></ul><p><code>public interface Powered extends Moveable</code></p><ul><li>接口中不含实例域，却可以包含常量（publice static final)</li><li>可以为接口提供默认实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span></span>&#123;<span class="keyword">return</span> <span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个类可以有多个接口</li></ul><ul><li><p><strong>继承时容易出现的问题：</strong></p><p>例如子类继承compareTo方法时，必须要有<strong>子类与超类进行比较</strong>的思想，就像第五章equals方法一样，不然会有<strong>ClassCastException</strong>错误。</p></li><li><p>只有一个抽象方法，并用lambda表达式替代，这种接口叫<strong>函数式接口</strong>；不含任何方法的接口叫<strong>标记接口</strong>，如 Cloneable。</p></li></ul><h2 id="解决接口冲突"><a href="#解决接口冲突" class="headerlink" title="解决接口冲突"></a>解决接口冲突</h2><p>同名，且参数类型相同下：</p><p>1）超类优先</p><p>2）接口冲突：只要其中一个接口提供了默认方法，就会报错；如果都不提供，就是抽象类。</p><p>ps. 类优先的机制确保了与java SE 7 的兼容，因为那时没有默认方法。</p><h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><h2 id="为什么引入lambda表达式呢？"><a href="#为什么引入lambda表达式呢？" class="headerlink" title="为什么引入lambda表达式呢？"></a>为什么引入lambda表达式呢？</h2><p><code>Arrays.sort(strings, new LengthComparator());</code></p><p>这段代码用定制的比较器完成字符串排序，可以看出它传入了一个对象（接口），这个对象实现了Camparable接口，对象里面有compare方法。我们主要目的就是想传递这个方法，但是Java之前只能通过构造对象，来传递该方法。于是lambda表达式正式引入！</p><h2 id="lambda表达式语法"><a href="#lambda表达式语法" class="headerlink" title="lambda表达式语法"></a>lambda表达式语法</h2><p>例子：</p><p><code>(String first, String second) -&gt; {...}</code></p><p>把它替换到之前到代码中：</p><p><code>Array.sort(strings, (fisrt, second)-&gt;first.length() - second.length());</code></p><p>一些细节：</p><ul><li>如果可以推导出参数类型，那么类型可以不写；而且如果只有这一个参数，小括号也可以不写。</li><li>如果某些分支返回一个值，而另一些分支不返回值，这是不合法的。<br><code>(int) -&gt; {if(x &gt;= 0) return 1;} //不合法</code></li><li>对于只有一个抽象方法的接口，可以提供一个lambda，就像例子；这种接口称为函数式接口。常的用函数式接口有：Predicate, Consumer, Function, Supplier 等等。</li></ul><h2 id="方法引用与lambda"><a href="#方法引用与lambda" class="headerlink" title="方法引用与lambda"></a>方法引用与lambda</h2><p>假如想传递的 lambda 已经有了现成的方法，那么可以用方法引用来代替lambda。<br>三种情况：</p><ol><li><p>静态方法</p><ul><li>Lambda: <code>(args) -&gt; ClassName.staticMethod(args)</code></li><li>方法引用：<code>ClassName::staticMethod</code></li></ul></li><li><p>现有对象的实例方法</p><ul><li>Lambda: <code>(args) -&gt; expr.instanceMethod(args)</code></li><li>方法引用：<code>expr::intanceMethod</code></li></ul></li><li><p>某类的实例方法</p><ul><li>Lambda: <code>(arg0, rest) -&gt; arg0.instanceMethod(rest)</code></li><li>方法引用：<code>ClassName::instanceMethod //arg0 是 ClassName 类型的</code></li></ul></li></ol><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>lambda 表达式可以访问外围方法或类中的变量，但需注意：</p><ul><li>该变量必须是最终变量，不可以重新赋值；如String</li><li>在 lambda 表达式中声明与一个局部变量同名的参数或局部变量是不合法的。</li><li>在一个 lambda 表达式中使用 this 关键字时， 是指创建这个 lambda 表达式的方法的 this 参数。 简单说就是没变化。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 java 接口和lambda表达式的总结&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
</feed>
