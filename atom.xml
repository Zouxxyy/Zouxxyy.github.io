<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZxysHexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-09T01:28:15.128Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zouxxyy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spark-DataFrame和DataSet</title>
    <link href="http://yoursite.com/2019/09/09/spark-DataFrame%E5%92%8CDataSet/"/>
    <id>http://yoursite.com/2019/09/09/spark-DataFrame和DataSet/</id>
    <published>2019-09-09T01:26:14.000Z</published>
    <updated>2019-09-09T01:28:15.128Z</updated>
    
    <content type="html"><![CDATA[<p>介绍了在spark中DataFrame和DataSet，以及它们之间的相互转换。</p><a id="more"></a><h1 id="概念分析"><a href="#概念分析" class="headerlink" title="概念分析"></a>概念分析</h1><p><strong>DataFrame</strong></p><p>类似传统数据库的二维表格，除了数据以外，还记录数据的结构信息，即schema。也就是普通RDD添加结构化信息得到。</p><p><strong>DataSet</strong></p><p>强类型的，存储的是对象。由<code>DataFrame</code>添加类属性得到。</p><p>相同点</p><ul><li><p>都是基于RDD的，所以都有RDD的特性，如懒加载，分布式，不可修改，分区等等。但执行sql性能比RDD高，因为spark自动会使用优化策略执行。说白了你手撸的干不过开发者写的。</p></li><li><p>均支持sparksql的操作，还能注册临时表，进行sql语句操作</p></li><li><p><code>DataFrame</code>和<code>Dataset</code>均可使用模式匹配获取各个字段的值和类型</p></li><li><p><code>DataFrame</code>也叫<code>Dataset[Row]</code>，每一行的类型是Row </p></li></ul><p>不同点</p><p>因为<code>DataFrame</code>也叫<code>Dataset[Row]</code>，所以我们理解了<strong>Row</strong>和<strong>普通对象</strong>的区别就好办了</p><ul><li><p><strong>Row</strong>的数据结构类似一个数组，只有顺序，切记。<strong>普通对象</strong>的数据结构也就是对象。</p></li><li><p>因此，访问<strong>Row</strong>只能通过如：<code>getInt(i: Int)</code>解析数据 或者 通过模式匹配得到数据；而<strong>普通对象</strong>可以通过 <code>.</code>号 直接访问对象中成员变量。</p></li><li><p>同理，<strong>Row</strong>中数据没类型，没办法在编译的时候检查是否有类型错误（弱类型的概念）；相反<strong>普通对象</strong>可以（强类型）。</p></li></ul><h1 id="RDD、DataFrame和DataSet转换"><a href="#RDD、DataFrame和DataSet转换" class="headerlink" title="RDD、DataFrame和DataSet转换"></a>RDD、DataFrame和DataSet转换</h1><p><img src="https://zouxxyy.s3-us-west-2.amazonaws.com/blog/spark/dataframe2dataset.png" alt></p><p><strong>注意</strong></p><ul><li><p>原始RDD类型是 <code>RDD[(Int, String)]</code></p></li><li><p>DataFrame -&gt; RDD 时，变成了<code>RDD[Row]</code></p></li><li><p>DataSet -&gt; RDD时，变成了<code>RDD[User]</code></p></li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="SQL风格（主要）"><a href="#SQL风格（主要）" class="headerlink" title="SQL风格（主要）"></a>SQL风格（主要）</h2><ul><li>创建一个DataFrame</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val df: DataFrame = spark.read.json(<span class="string">"people.json"</span>)</span><br></pre></td></tr></table></figure><ul><li>对DataFrame创建一个临时表(临时表是Session范围内有效，也可以创建全局的)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.createOrReplaceTempView(<span class="string">"people"</span>)</span><br></pre></td></tr></table></figure><ul><li>通过SQL语句实现对表的操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark.sql(<span class="string">"SELECT * FROM people"</span>).show()</span><br></pre></td></tr></table></figure><h2 id="DSL风格（次要）"><a href="#DSL风格（次要）" class="headerlink" title="DSL风格（次要）"></a>DSL风格（次要）</h2><ul><li>创建一个DataFrame</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val df: DataFrame = spark.read.json(<span class="string">"people.json"</span>)</span><br></pre></td></tr></table></figure><ul><li>使用DataFrame的api</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.select(<span class="string">"name"</span>).show()</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.select($<span class="string">"name"</span>, $<span class="string">"age"</span> + <span class="number">1</span>).show()</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><code>DataFrame</code>和<code>Dataset</code>都是为了方便我们执行sql的，因此当我们把数据转化成它们之后，写好sql逻辑，剩下的就交给咱们spark吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍了在spark中DataFrame和DataSet，以及它们之间的相互转换。&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="spark" scheme="http://yoursite.com/tags/spark/"/>
    
      <category term="sparksql" scheme="http://yoursite.com/tags/sparksql/"/>
    
  </entry>
  
  <entry>
    <title>spark-窄、宽依赖和任务划分</title>
    <link href="http://yoursite.com/2019/09/09/spark-%E7%AA%84%E3%80%81%E5%AE%BD%E4%BE%9D%E8%B5%96%E5%92%8C%E4%BB%BB%E5%8A%A1%E5%88%92%E5%88%86/"/>
    <id>http://yoursite.com/2019/09/09/spark-窄、宽依赖和任务划分/</id>
    <published>2019-09-09T01:13:52.000Z</published>
    <updated>2019-09-09T01:25:22.763Z</updated>
    
    <content type="html"><![CDATA[<p>介绍了在spark中窄、宽依赖的划分以及任务划分</p><a id="more"></a><h1 id="窄依赖和宽依赖"><a href="#窄依赖和宽依赖" class="headerlink" title="窄依赖和宽依赖"></a>窄依赖和宽依赖</h1><h2 id="窄依赖"><a href="#窄依赖" class="headerlink" title="窄依赖"></a>窄依赖</h2><ul><li>每一个父RDD的Partition最多被子RDD的一个Partition使用</li><li>独生子女：一个爹RDD只有一个子</li></ul><p><img src="https://zouxxyy.s3-us-west-2.amazonaws.com/blog/spark/dependence/Narrow-dependence.png" alt></p><h2 id="宽依赖"><a href="#宽依赖" class="headerlink" title="宽依赖"></a>宽依赖</h2><ul><li>每一个父RDD的Partition被子RDD的多个Partition使用，伴随shuffle</li><li>超生：一个爹RDD有多个子</li></ul><p><img src="https://zouxxyy.s3-us-west-2.amazonaws.com/blog/spark/dependence/Wide.jpg" alt></p><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>由于还没学shuffle，所以从宏观简单思考。学一个东西不能死记硬背，最好的理解就是：问问自己<strong>为啥要分窄依赖和宽依赖？</strong></p><p>先分析例子：</p><ul><li>例1：用map时，一个分区里的数据经过函数，形成新的数据，大家你搞你的我搞我的，互不干扰。</li><li>例2：用合并操作时，多个分区合到一个分区，同样，各走各的，顶走跑之前计算下新偏移量（这个偏移别人没跑完我也知道），也可以说是互不干扰</li><li>例3：用groupbykey时，这下可不是互不干扰了，因为需要比较洗牌，你得等你的伙伴（另一个分区）算完了，才能执行groupbykey。</li></ul><p>因此我觉得这就是所谓的宽依赖：<strong>别的分区没跑完，不能执行下一步，需要等待</strong>。只有当大家都准备好了，才可以一起进行洗牌。由于分区里的数据顺序之前是乱的，所以shuffle时一般都会拆开，然后送到不同的子分区。这就造成了结果——超生。说实话，如果你从结果出发去思考，是不好区分例2例3的。</p><p>接着，划分窄依赖（<strong>别的分区没跑完，可以执行下一步</strong>）和宽依赖（<strong>别的分区没跑完，不可以执行下一步</strong>）的原因显而易见。我们可以把窄依赖的步骤划分到一起，它可以一路执行，不需要等待，直到宽依赖步骤卡住（必须等其它分区执行完）。这个从窄依赖一路执行到宽依赖的过程，可以在逻辑上划分成一个<strong>stage</strong>。这也就是常说的<strong>宽依赖是划分Stage的依据</strong>。</p><p><img src="https://zouxxyy.s3-us-west-2.amazonaws.com/blog/spark/dependence/stage.jpg" alt></p><h1 id="任务划分"><a href="#任务划分" class="headerlink" title="任务划分"></a>任务划分</h1><p>RDD任务的切分，分为：Application、Job、Stage和Task，而且每一层都是<strong>1对n</strong>的关系</p><h2 id="4个名词"><a href="#4个名词" class="headerlink" title="4个名词"></a>4个名词</h2><ul><li><strong>Application</strong>：初始化一个SparkContext即生成一个Application</li><li><strong>Job</strong>：一个Action算子就会生成一个Job</li><li><strong>Stage</strong>：根据RDD之间的依赖关系的不同将Job划分成不同的Stage，遇到一个宽依赖则划分一个Stage。</li><li><strong>Task</strong>：Stage是一个TaskSet，将Stage划分的结果发送到不同的Executor执行即为一个Task。</li></ul><h2 id="个人理解-1"><a href="#个人理解-1" class="headerlink" title="个人理解"></a>个人理解</h2><p>同样思考为啥要划分这么多东西？</p><ul><li><strong>Application</strong></li></ul><p>一个spark不止跑一个程序吧，所以一个程序一个 Application理所当然，进而生成一个AppMaster管理它。</p><ul><li><strong>Job</strong></li></ul><p>一个程序有许多转换算子和行动算子。只有执行到<strong>行动操作才真正改变数据</strong>，所以把截止到行动算子的算子划一个job合情合理吧。而且我们从源码也可以看到，执行一个行动操作，就会执行<code>sc.runJob(...)</code></p><ul><li><strong>Stage</strong></li></ul><p>在一个Job中，有的可一路执行到宽依赖的，不需要等待，按这个划分为一个Stage。这个不理解的再看看上面的分析。</p><ul><li><strong>Task</strong></li></ul><p>在一个Stage中，我们观察最后一组分区，也就是shuffer前的，由于到这里都是可以一路执行的，所以按最后一组分区的个数，一个分区划一个Task。此时都划到分区了，自然不用划分了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍了在spark中窄、宽依赖的划分以及任务划分&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="spark" scheme="http://yoursite.com/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>spark-Yarn流程解析</title>
    <link href="http://yoursite.com/2019/09/02/spark-Yarn%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/09/02/spark-Yarn流程解析/</id>
    <published>2019-09-02T08:13:28.000Z</published>
    <updated>2019-09-09T01:12:27.955Z</updated>
    
    <content type="html"><![CDATA[<p>介绍了在spark中Yarn的工作流程和一些总结</p><a id="more"></a><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p><img src="https://zouxxyy.s3-us-west-2.amazonaws.com/blog/spark/spark-yarn.png" alt="YARN-Cluster流程图" title="YARN-Cluster流程图"></p><p>主要流程和<a href="https://zouxxyy.github.io/2019/08/31/hadoop-Yarn%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/#more" target="_blank" rel="noopener">Yarn的流程</a>一样，不同的就是紫色部分。这里采用的是spark的<strong>yarn-cluster</strong>模式，driver在APPMaster中。</p><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><h2 id="解耦思想"><a href="#解耦思想" class="headerlink" title="解耦思想"></a>解耦思想</h2><ul><li><p>ResourceManager管理资源调度，与NodeManager直接联系；Driver负责执行计算，与Executor也就是一个个Task直接联系。</p></li><li><p><strong>计算和资源调度解耦</strong>：ResourceManager和Driver靠中间件AppMaster联系起来；Executor和NodeManager靠中间件Container联系起来</p></li><li><p>此时计算框架是<strong>可插拔</strong>的，如：spark计算框架（紫色部分）代替mapreduce。</p></li></ul><h2 id="Client和Cluster模式"><a href="#Client和Cluster模式" class="headerlink" title="Client和Cluster模式"></a>Client和Cluster模式</h2><p>spark上yarn有两种管理模式，<strong>YARN-Client</strong>和<strong>YARN-Cluster</strong>。</p><p>主要区别是：SparkContext初始化位置不同，也就是了Driver所在位置的不同。</p><table><thead><tr><th align="center">client</th><th align="center">master</th></tr></thead><tbody><tr><td align="center">driver在Client上</td><td align="center">driver在AppMaster上</td></tr><tr><td align="center">日志可以直接在Client上看到</td><td align="center">日志在某个节点上</td></tr><tr><td align="center">Client连接不能断开</td><td align="center">Client连接可以断开</td></tr><tr><td align="center">适合交互和调试</td><td align="center">适合生产环境</td></tr></tbody></table><h1 id="其它管理模式"><a href="#其它管理模式" class="headerlink" title="其它管理模式"></a>其它管理模式</h1><h2 id="local模式"><a href="#local模式" class="headerlink" title="local模式"></a>local模式</h2><p>单机模式 <code>--master local[*]</code></p><h2 id="Standalone模式"><a href="#Standalone模式" class="headerlink" title="Standalone模式"></a>Standalone模式</h2><p>不用Yarn，用Spark自带的Standalone资源管理器，它把节点分成<strong>Master</strong>和<strong>Worker</strong>。类似RM和NM，但它没有AppMaster。也分为Client模式和cluster模式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍了在spark中Yarn的工作流程和一些总结&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="yarn" scheme="http://yoursite.com/tags/yarn/"/>
    
      <category term="spark" scheme="http://yoursite.com/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>hadoop-Yarn流程解析</title>
    <link href="http://yoursite.com/2019/08/31/hadoop-Yarn%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/08/31/hadoop-Yarn流程解析/</id>
    <published>2019-08-31T10:50:22.000Z</published>
    <updated>2019-09-02T03:25:39.261Z</updated>
    
    <content type="html"><![CDATA[<p>介绍了Yarn的工作流程和一些总结</p><a id="more"></a><h1 id="Yarn运行机制流程图"><a href="#Yarn运行机制流程图" class="headerlink" title="Yarn运行机制流程图"></a>Yarn运行机制流程图</h1><p><img src="https://github.com/Zouxxyy/bigdata-learning/blob/master/hadoop-learning/data/image/Yarn.png?raw=true" alt="Yarn运行机制流程图" title="Yarn运行机制流程图"></p><h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><p>（1）作业提交</p><ol start="0"><li>Client调用<code>job.waitForCompletion</code>方法，向整个集群提交MapReduce作业。</li><li>Client向RM申请一个作业id。 </li><li>RM给Client返回该job资源的提交路径(<code>hdfs://.../.staging/</code>)和作业<code>application_id</code>。</li><li>Client在该路径提交jar包、切片信息和配置文件。</li><li>Client提交完资源后，向RM申请运行MrAppMaster。</li></ol><p>（2）作业初始化</p><ol start="5"><li>当RM收到Client的请求后，将该job添加到资源调度器中，将job初始化成task。</li><li>某一个空闲的NM领取到该Job。</li><li>在该NM中创建Container，并产生MRAppmaster(一个job创建一个)，它管理该job。</li><li>下载之前Client提交的资源到本地。</li></ol><p>（3）任务分配</p><ol start="9"><li>MRAppMaster向RM申请运行多个MapTask任务资源。</li><li>RM将运行MapTask任务分配给另外两个NodeManager，另外两个NodeManager分别领取任务并创建容器。</li></ol><p>（4）任务执行</p><ol start="11"><li>MR向两个接收到任务的NodeManager发送程序启动脚本，这两个NodeManager分别启动MapTask，MapTask对数据分区排序。</li><li>MrAppMaster等待所有MapTask运行完毕后，向RM申请容器，运行ReduceTask。</li><li>ReduceTask向MapTask获取相应分区的数据。</li><li>程序运行完毕后，MR会向RM申请注销自己。</li></ol><h1 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h1><h2 id="4大组件"><a href="#4大组件" class="headerlink" title="4大组件"></a>4大组件</h2><ul><li><strong>ResourceManager</strong>：总的老大：处理客户端请求，监控NodeManager，启动或监控ApplicationMaster，资源的分配与调度</li><li><strong>NodeManager</strong>：单个节点的老大：管理单个节点的资源，处理来自ResourceManager、ApplicationMaster的命令</li><li><strong>ApplicationMaster</strong>：单个job的老大：负责数据切分，为应用程序申请资源并分配内部的任务，任务的监控与容错</li><li><strong>Container</strong>：资源抽象：如内存、cpu、磁盘、网络等</li></ul><h2 id="3种资源调度器"><a href="#3种资源调度器" class="headerlink" title="3种资源调度器"></a>3种资源调度器</h2><ul><li><strong>FIFO</strong>：先进先出</li><li><strong>Capacity Scheduler</strong>：多FIFO队列，会对同一用户提交资源进行限定，会把任务分配给更闲的队列。</li><li><strong>Fair Scheduler</strong>：多队列，按缺额排序，缺额大者优先执行</li></ul><h2 id="任务推测执行机制"><a href="#任务推测执行机制" class="headerlink" title="任务推测执行机制"></a>任务推测执行机制</h2><ul><li>问题：系统中有99%的Map任务都完成了，只有少数几个Map老是进度很慢，完不成。</li><li>办法：为拖后腿任务启动一个备份任务，同时运行。谁先运行完，则采用谁的结果。</li><li>前提：每个Task只能有一个备份任务，当前Job已完成的Task必须不小于0.05（5%）。</li><li>不适用：任务间存在严重的负载倾斜；特殊任务，比如任务向数据库中写数据。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍了Yarn的工作流程和一些总结&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
      <category term="yarn" scheme="http://yoursite.com/tags/yarn/"/>
    
  </entry>
  
  <entry>
    <title>hadoop-HDFS流程解析</title>
    <link href="http://yoursite.com/2019/08/31/hadoop-HDFS%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/08/31/hadoop-HDFS流程解析/</id>
    <published>2019-08-31T07:04:57.000Z</published>
    <updated>2019-08-31T07:12:19.630Z</updated>
    
    <content type="html"><![CDATA[<p>介绍了HDFS读写数据、NameNode和SecondaryNameNode、DataNode和NameNode的交互</p><a id="more"></a><h1 id="HDFS写数据"><a href="#HDFS写数据" class="headerlink" title="HDFS写数据"></a>HDFS写数据</h1><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://github.com/Zouxxyy/bigdata-learning/blob/master/hadoop-learning/data/image/readHDFS.png?raw=true" alt="HDFS写数据" title="HDFS写数据"></p><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><ol><li>客户端调用DS模块向NameNode请求上传文件。</li><li>NameNode会检查目标文件和父目录是否已存在，再返回是否可以上传</li><li>假设文件为200M，客户端请求上传第一个 Block ，希望得到DataNode服务器位置。</li><li>NameNode返回3个DataNode节点，分别为dn1、dn2、dn3，用它们存储数据。</li><li>客户端通过FSDataOutputStream模块请求dn1建立上传数据通道，dn1收到请求会继续请求dn2，然后dn2请求dn3，直到将这个通信管道建立完成。</li><li>dn3、dn2、dn1逐级应答客户端。</li><li>客户端开始往dn1上传第一个Block（先从磁盘读取数据放到一个本地内存缓存），以Packet为单位，dn1收到一个Packet就会传给dn2，dn2传给dn3；dn1每传一个packet会放入一个应答队列等待应答。（类似队列，以Packet为单位）</li><li>当一个Block（0-128M）传输完成之后，客户端再次请求NameNode上传第二个Block的服务器。（重复执行3-7步）。</li><li>向NameNode汇报上传完毕。</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>DataNode位置选择，以默认3副本为例：第一个副本是最近的一般是它自己；第二个副本选择同一机架（同一路由）的不同节点；第三个副本是另一机架的随机节点。</li><li>数据传递以包为单位，第一个节点收到一个包，就把包传递给下一个DataNode。并不是等数据传完，再传递。</li></ul><h1 id="HDFS读数据"><a href="#HDFS读数据" class="headerlink" title="HDFS读数据"></a>HDFS读数据</h1><h2 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://github.com/Zouxxyy/bigdata-learning/blob/master/hadoop-learning/data/image/writeHDFS.png?raw=true" alt="HDFS读数据" title="HDFS读数据"></p><h2 id="具体步骤-1"><a href="#具体步骤-1" class="headerlink" title="具体步骤"></a>具体步骤</h2><ol><li>客户端调用DS模块向NameNode请求下载文件。</li><li>NameNode会检查目标文件是否存在，再通过查询元数据，返回文件块所在的DataNode地址。</li><li>客户端通过FSDataInputStream模块向dn1（就近挑选）请求读取 Block1。</li><li>DataNode开始传输数据给客户端（从磁盘里面读取数据输入流，以Packet为单位来做校验）。客户端以Packet为单位接收，先在本地缓存，然后写入目标文件。</li><li>当一个Block（0-128M）传输完成之后，客户端再次请求下载Block2。（重复执行2-4步）。</li><li>向NameNode汇报下载完毕。</li></ol><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>如果块的第一个副本请求失败，会向第二个副本请求，依次类推。</li></ul><h1 id="NameNode和SecondaryNameNode"><a href="#NameNode和SecondaryNameNode" class="headerlink" title="NameNode和SecondaryNameNode"></a>NameNode和SecondaryNameNode</h1><h2 id="流程图-2"><a href="#流程图-2" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://github.com/Zouxxyy/bigdata-learning/blob/master/hadoop-learning/data/image/NNand2NN.png?raw=true" alt="NameNode和SecondaryNameNode" title="NameNode和SecondaryNameNode"></p><h2 id="具体步骤-2"><a href="#具体步骤-2" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>第一阶段：NameNode</p><ol><li>第一次启动NameNode（格式化）后，会创建Fsimage（镜像文件）和Edits（编辑日志）文件。以后启动，会直接加载镜像文件和编辑日志到内存，此时会进行合并操作。</li><li>假设此时客户端提出了增删改的请求。</li><li>NameNode记录之前的编辑日志（edits_n），更新新日志到滚动日志（edits_inprogress_n）中。</li><li>日志记录完毕后，NameNode在内存中对数据进行增删改。</li></ol><p>第二阶段：SecondaryNameNode</p><ol><li>Secondary NameNode向NameNode询问是否需要CheckPoint。</li><li>如果需要，Secondary NameNode请求执行CheckPoint。</li><li>NameNode滚动日志。</li><li>将滚动前的编辑日志（edits_001）和镜像文件(fsimage)拷贝到Secondary NameNode。</li><li>Secondary NameNode加载编辑日志和镜像文件到内存，并合并。</li><li>合并后，生成新的镜像文件fsimage.chkpoint。</li><li>拷贝fsimage.chkpoint到NameNode。</li><li>NameNode将fsimage.chkpoint重新命名成fsimage。</li></ol><h2 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>Fsimage 和 Edits文件？</li></ul><p>fsimage是NameNode内存中元数据序列化后形成的文件。Edits中记录客户端更新元数据信息的每一步操作。每次执行增删改时，先改日志再改文件。好处是：如果保证中途gg，可以保证操作不丢失，便于复原。</p><ul><li>为啥要Secondary NameNode？</li></ul><p>首先要知道只有NameNode重启时，edit.log才会合并到fsimage文件中，所以运行时间久了就会有3个问题：edis.log文件会变的很大；NameNode下次重启会花费很长时间；fsimage文件文件很旧，如果中途挂掉就很睿智。</p><p>为了解决上述问题，SecondaryNameNode诞生，每隔一定时间辅助合并NameNode的edit.log到fsimage文件中。从上述流程图就可以发现，它做的就是这个。</p><ul><li>什么时候执行CheckPoint？</li></ul><p>（1） 用户定时 （2）edit.log 满了</p><ul><li>Secondary NameNode是热备份吗？</li></ul><p>不是，可以发现Secondary NameNode合并的是滚动前的edis，它总是比NameNode的编辑日志少一点。</p><h1 id="DataNode和NameNode"><a href="#DataNode和NameNode" class="headerlink" title="DataNode和NameNode"></a>DataNode和NameNode</h1><h2 id="流程图-3"><a href="#流程图-3" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://github.com/Zouxxyy/bigdata-learning/blob/master/hadoop-learning/data/image/DataNode.png?raw=true" alt="NameNode和DataNode" title="NameNode和DataNode"></p><h2 id="具体步骤-3"><a href="#具体步骤-3" class="headerlink" title="具体步骤"></a>具体步骤</h2><ol><li>DataNode启动后向NameNode注册。</li><li>NameNode告知注册成功。</li><li>DataNode周期性（1小时）的向NameNode上报所有的块信息。</li><li>DataNode每3秒发送一次心跳，心跳返回结果带有NameNode给该DataNode的命令如复制块数据到另一台机器，或删除某个数据块。</li><li>超过10分钟没有收到心跳，表示该节点不可用。</li></ol><h2 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>一个数据块在DataNode上以文件形式存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度、校验和 以及时间戳。</li><li>节点增加：新节点配置好后，自动向NameNode注册的。</li><li>节点退役：NameNode可以通过白名单指定需要的节点；通过黑名单指定不要的节点。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍了HDFS读写数据、NameNode和SecondaryNameNode、DataNode和NameNode的交互&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
      <category term="HDFS" scheme="http://yoursite.com/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>hadoop-MapReduce流程解析</title>
    <link href="http://yoursite.com/2019/08/30/hadoop-MapReduce%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/08/30/hadoop-MapReduce流程解析/</id>
    <published>2019-08-30T08:38:07.000Z</published>
    <updated>2019-08-31T11:10:05.944Z</updated>
    
    <content type="html"><![CDATA[<p>介绍了MapReduce的详细流程和一些总结</p><a id="more"></a><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="https://github.com/Zouxxyy/bigdata-learning/blob/master/hadoop-learning/data/image/MapTask.png?raw=true" alt="MapTask流程图" title="MapTask流程图"></p><p><img src="https://github.com/Zouxxyy/bigdata-learning/blob/master/hadoop-learning/data/image/ReduceTask.png?raw=true" alt="ReduceTask流程图" title="ReduceTask流程图"></p><p><img src="https://github.com/Zouxxyy/bigdata-learning/blob/master/hadoop-learning/data/image/Shuffer.png?raw=true" alt="Shuffer流程图" title="Shuffer流程图"></p><h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><p>逻辑上可以这样划分：1-10是MapTask ；11-16是ReduceTask；7-14是shuffer</p><h3 id="1-待处理文本"><a href="#1-待处理文本" class="headerlink" title="1. 待处理文本"></a><strong>1. 待处理文本</strong></h3><p>这里假设是<code>/user/input</code>目录下的<code>ss.txt</code>    文件，大小为<strong>200M</strong>。</p><h3 id="2-客户端submit（）"><a href="#2-客户端submit（）" class="headerlink" title="2. 客户端submit（）"></a><strong>2. 客户端submit（）</strong></h3><p>发生在client端，主要获取3个信息：</p><p>（1）<strong>Job.split</strong> ：找到文件ss.txt，根据切片算法，得到切片的元数据信息（起始位置，长度以及所在节点等）如把ss.txt分成两片 0-128M 和 128M-200M</p><p>（2）<strong>Job.xml</strong>：任务的配置信息</p><p>（3）<strong>wc.jar</strong>：任务的jar包</p><p>（可以在<code>/tmp/hadoop-zxy/mapred/staging/zxy1248702679/.staging/</code>下找到它们）</p><h3 id="3-提交信息"><a href="#3-提交信息" class="headerlink" title="3. 提交信息"></a><strong>3. 提交信息</strong></h3><p>将刚刚获取的任务规划信息，提交到资源管理器上，我们这里用Yarn。</p><h3 id="4-RM计算MapTask数量"><a href="#4-RM计算MapTask数量" class="headerlink" title="4. RM计算MapTask数量"></a><strong>4. RM计算MapTask数量</strong></h3><p>接着向Yarn的RM申请资源，RM根据任务规划信息用户Job分成Task，并把任务下发给节点。这里我们数据分成了2片，根据默认规则，会有2个MapTask各自处理一片数据。</p><h3 id="5-根据采用的InputFormat读取数据"><a href="#5-根据采用的InputFormat读取数据" class="headerlink" title="5. 根据采用的InputFormat读取数据"></a><strong>5. 根据采用的InputFormat读取数据</strong></h3><p>这里采用默认的TextInputFormat类，按行读取每条记录。key是行偏移量，value是该行的内容。</p><h3 id="6-执行Mapper的map"><a href="#6-执行Mapper的map" class="headerlink" title="6. 执行Mapper的map()"></a><strong>6. 执行Mapper的map()</strong></h3><p>根据用户的代码执行map逻辑，把结果写入Context中。</p><h3 id="7-向环形缓存区写入数据"><a href="#7-向环形缓存区写入数据" class="headerlink" title="7. 向环形缓存区写入数据"></a><strong>7. 向环形缓存区写入数据</strong></h3><p>环形缓存区取一点：一边写索引，一边写真实数据。达到80%时发生溢写</p><h3 id="8-分区、排序"><a href="#8-分区、排序" class="headerlink" title="8. 分区、排序"></a><strong>8. 分区、排序</strong></h3><p>一种2次排序，先按区号排，再对key排序（快排）。得到一组按区排好序的数据。注意：这步是在环形缓存区就可以执行的，且排序排的是索引，真实数据不用动。且此时可以使用第一次Combiner合并操作。</p><h3 id="9-溢出写入文件"><a href="#9-溢出写入文件" class="headerlink" title="9. 溢出写入文件"></a><strong>9. 溢出写入文件</strong></h3><p>环形缓存区达到80%时，溢写到磁盘上。注意写磁盘前已经完成了分区、排序、合并、压缩等操作。此时生成第一组溢写文件<code>spillN.out</code> 与元数据<code>spillN.out.index</code>。</p><h3 id="10-MapTask的归并排序"><a href="#10-MapTask的归并排序" class="headerlink" title="10. MapTask的归并排序"></a><strong>10. MapTask的归并排序</strong></h3><p>将多组溢写文件，以分区为单位进行归并排序，写入磁盘形成大文件<code>output/file.out</code>，与索引文件<code>output/file.out.index</code>。此时一个MapTask任务完成，得到一个分区有序的数据。注意：在归并排序时可以使用第二次Combiner合并操作。</p><h3 id="11-启动ReduceTask"><a href="#11-启动ReduceTask" class="headerlink" title="11. 启动ReduceTask"></a><strong>11. 启动ReduceTask</strong></h3><p>假设分区数为2，此时启动2个ReduceTask，一个ReduceTask处理一个区的数据。</p><h3 id="12-copy数据"><a href="#12-copy数据" class="headerlink" title="12. copy数据"></a><strong>12. copy数据</strong></h3><p>ReduceTask从各个MapTask上拷贝它要处理的区的数据，如果其大小超过一定阈值，则写到磁盘上，否则直接放到内存中。</p><h3 id="13-ReduceTask的归并排序"><a href="#13-ReduceTask的归并排序" class="headerlink" title="13. ReduceTask的归并排序"></a><strong>13. ReduceTask的归并排序</strong></h3><p>把同区的数据复制到同一个ReduceTask后，对它们进行归并排序</p><h3 id="14-分组"><a href="#14-分组" class="headerlink" title="14. 分组"></a><strong>14. 分组</strong></h3><p>默认把key相同的数据分到一组。用户可以继承WritableComparator，自定义分组规则。</p><h3 id="15-执行Reducer的Reduce"><a href="#15-执行Reducer的Reduce" class="headerlink" title="15. 执行Reducer的Reduce()"></a><strong>15. 执行Reducer的Reduce()</strong></h3><p>根据用户的代码执行reduce逻辑，把结果写入Context中。注意：一次读一组，value是迭代器对象，包含一个组的全部数据。</p><h3 id="16-根据采用的OutputFormat读取数据"><a href="#16-根据采用的OutputFormat读取数据" class="headerlink" title="16. 根据采用的OutputFormat读取数据"></a><strong>16. 根据采用的OutputFormat读取数据</strong></h3><p>这里采用默认的TextOutputFormat类，按行写入key和value，key和value用tab分开。</p><h1 id="一些总结"><a href="#一些总结" class="headerlink" title="一些总结"></a>一些总结</h1><h3 id="1个逻辑"><a href="#1个逻辑" class="headerlink" title="1个逻辑"></a><strong>1个逻辑</strong></h3><p><strong>先分区 -&gt; 再排序 -&gt; 再分组</strong></p><p>分区：用户定义分区数后，默认按hash分区。用户也可以继承<code>Partitioner</code>，自定义分区规则。ReduceTask的个数一般等于分区数。</p><p>排序：默认对key排序，key必须实现<code>WritableComparable</code>接口。用户可以重写<code>WritableComparable</code>接口的<code>compareTo()</code>方法，定义自己的排序规则。</p><h3 id="2次合并"><a href="#2次合并" class="headerlink" title="2次合并"></a><strong>2次合并</strong></h3><p>Combiner的父类就是Reducer，它可以通过对Map阶段的局部结果进行汇总，减少输出。</p><p>时机： 2次，<strong>分区排序后、MapTask的归并排序时</strong>。</p><p>条件：不能影响业务逻辑 且 输入输出的范型一致</p><h3 id="3次排序"><a href="#3次排序" class="headerlink" title="3次排序"></a><strong>3次排序</strong></h3><p>MapTask：</p><p><strong>分区排序</strong>：在缓行缓冲区进行，是一种2次排序。先按分区号排序，再对key排序（快排）。</p><p><strong>归并排序</strong>：对每组溢写的数据，进行的按区，归并排序。</p><p>ReduceTask：</p><p><strong>归并排序</strong>：对从MapTask拷贝的同区数据，进行的归并排序。</p><h3 id="分片和分区"><a href="#分片和分区" class="headerlink" title="分片和分区"></a><strong>分片和分区</strong></h3><p>分片：<strong>分片数决定MapTask的个数</strong>。在客户端即完成，举FileInputFormat切片机制为例：简单的按文件长度进行切片，切片大小等于块大小（默认128M），切片时是对文件单独切片。</p><p>分区：<strong>分区数决定ReduceTask的个数</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍了MapReduce的详细流程和一些总结&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
      <category term="mapreduce" scheme="http://yoursite.com/tags/mapreduce/"/>
    
  </entry>
  
  <entry>
    <title>hadoop-单节点伪分布式搭建</title>
    <link href="http://yoursite.com/2019/08/24/hadoop-%E5%8D%95%E8%8A%82%E7%82%B9%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/08/24/hadoop-单节点伪分布式搭建/</id>
    <published>2019-08-24T03:43:32.000Z</published>
    <updated>2019-08-24T03:45:18.483Z</updated>
    
    <content type="html"><![CDATA[<p>在mac上搭建hadoop伪分布式</p><a id="more"></a><p>操作系统： macOS Mojave 10.14.5</p><p>JDK : 1.8</p><p>hadoop: 2.7.7</p><h2 id="1-Java和Hadoop安装"><a href="#1-Java和Hadoop安装" class="headerlink" title="1. Java和Hadoop安装"></a>1. Java和Hadoop安装</h2><p>下载和安装相信都没问题</p><p>注意的就是：</p><ul><li>环境变量设置好，我是mac所以javahome是$(/usr/libexec/java_home);我是zsh所以修改.zshrc，修改完别忘了source。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#JAVA_HOME</span><br><span class="line">export JAVA_HOME=$(/usr/libexec/java_home)</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">#HADOOP_HOME</span><br><span class="line">export HADOOP_HOME=/usr/local/hadoop-2.7.7</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br></pre></td></tr></table></figure><ul><li>由于我将hadoop放在<code>/usr/local/</code>目录下，所以需要更改hadoop文件夹权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R zxy:admin /usr/local/hadoop-2.7.7</span><br></pre></td></tr></table></figure><h2 id="2-配置SSH"><a href="#2-配置SSH" class="headerlink" title="2. 配置SSH"></a>2. 配置SSH</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -P <span class="string">""</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">ssh localhost</span><br></pre></td></tr></table></figure><h2 id="3-伪分布式配置"><a href="#3-伪分布式配置" class="headerlink" title="3. 伪分布式配置"></a>3. 伪分布式配置</h2><h3 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h3><p>修改 <code>/usr/local/hadoop-2.7.7/etc/hadoop/core-site.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/usr/local/hadoop-2.7.7/data/tmp&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><ul><li><p><strong>fs.defaultFS</strong>  HDFS 的NameNode地址</p></li><li><p><strong>hadoop.tmp.dir</strong>  hadoop 临时文件地址，自己指定</p></li></ul><h3 id="hdfs-site-xml"><a href="#hdfs-site-xml" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h3><p>修改 <code>/usr/local/hadoop-2.7.7/etc/hadoop/hdfs-site.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">            &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>dfs.replication</strong>  HDFS文件存储的副本个数，默认3。因为我们这只有一个节点，所以设置1.（单一节点至多存一份节点）</li></ul><h3 id="yarn-site-xml"><a href="#yarn-site-xml" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h3><p>修改 <code>/usr/local/hadoop-2.7.7/etc/hadoop/yarn-site.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;localhost&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- 开启聚合日志 --&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.log.server.url&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;http://localhost:19888/jobhistory/logs&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>arn.log-aggregation-enable</strong> 开启日志聚合</li><li><strong>yarn.resourcemanager.hostname</strong>  yarn的ResourceManager地址</li></ul><h3 id="mapred-site-xml"><a href="#mapred-site-xml" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h3><p>修改 <code>/usr/local/hadoop-2.7.7/etc/hadoop/mapred-site.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;localhost:10020&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;localhost:19888&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>mapreduce.framework.name</strong>  采用yarn管理MR</li><li><strong>mapreduce.jobhistory.address</strong>  历史服务器端口地址</li><li><strong>mapreduce.jobhistory.webapp.address</strong>  历史服务器web端地址</li></ul><h3 id="检查JAVA-HOME"><a href="#检查JAVA-HOME" class="headerlink" title="检查JAVA_HOME"></a>检查JAVA_HOME</h3><p>hadoop-env.sh、mapred-env.sh、yarn-env.sh，在这三个文件检查是否添加JAVA_HOME路径，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=$JAVA_HOME</span><br></pre></td></tr></table></figure><h2 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h2><ul><li>开HDFS</li></ul><p>第一次使用要格式化(仅限第一次使用时，以后要格式化需删除log、data目录下的文件)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop namenode -format</span><br></pre></td></tr></table></figure><p>开启namenode、datanode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop-daemon.sh start namenode</span><br><span class="line">hadoop-daemon.sh start datanode</span><br></pre></td></tr></table></figure><ul><li>开yarn</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn-daemon.sh start resourcemanager</span><br><span class="line">yarn-daemon.sh start nodemanager</span><br></pre></td></tr></table></figure><ul><li>开historyserver</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mr-jobhistory-daemon.sh start historyserver</span><br></pre></td></tr></table></figure><ul><li>可以用jps查看效果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br><span class="line">35953 JobHistoryServer</span><br><span class="line">32930</span><br><span class="line">35682 NodeManager</span><br><span class="line">35990 Jps</span><br><span class="line">35559 DataNode</span><br><span class="line">35624 ResourceManager</span><br><span class="line">35502 NameNode</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><p>创建一个文件夹zxytest，里面随便放一个文件，上传到hdfs测试wordcount</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -put zxytest /</span><br><span class="line">hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.7.jar wordcount /zxytest /zxyout</span><br></pre></td></tr></table></figure><ul><li>关闭    </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mr-jobhistory-daemon.sh stop historyserver</span><br><span class="line">yarn-daemon.sh stop resourcemanager</span><br><span class="line">yarn-daemon.sh stop nodemanager</span><br><span class="line">hadoop-daemon.sh stop namenode</span><br><span class="line">hadoop-daemon.sh stop datanode</span><br></pre></td></tr></table></figure><ul><li>可视化地址</li></ul><p>所有任务: <a href="http://localhost:8088/" target="_blank" rel="noopener">http://localhost:8088/</a></p><p>DataNode: <a href="http://localhost:50070/" target="_blank" rel="noopener">http://localhost:50070/</a></p><p>历史服务器: <a href="http://localhost:19888/" target="_blank" rel="noopener">http://localhost:19888/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在mac上搭建hadoop伪分布式&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>3种Linux命令后台执行方法：&amp;、nohup、tmux</title>
    <link href="http://yoursite.com/2019/06/26/3%E7%A7%8DLinux%E5%91%BD%E4%BB%A4%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95%EF%BC%9A-%E3%80%81nohup%E3%80%81tmux/"/>
    <id>http://yoursite.com/2019/06/26/3种Linux命令后台执行方法：-、nohup、tmux/</id>
    <published>2019-06-26T03:25:03.000Z</published>
    <updated>2019-06-26T03:28:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>让命令在后台跑起来！</p><a id="more"></a><h1 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h1><p>用法：<code>指令 &amp;</code></p><p>说明： 将指令放入后台执行，会将输出打印到前台，<strong>当执行该指令的终端gg时，它也gg</strong></p><p>终止方法：</p><ul><li><code>jobs</code> 查看它 -&gt; <code>fg %num</code> 取出它 -&gt; <code>Ctrl+c</code>终止它</li><li>直接退出终端</li></ul><h1 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h1><p>用法：<code>nohup 指令 &amp;</code></p><p>说明： 将指令放入后台执行，不会将输出打印到前台，<strong>当执行该指令的终端gg时，它不gg</strong></p><p>终止方法：</p><ul><li>未退出终端时：<code>jobs</code> 查看它 -&gt; <code>fg %num</code> 取出它 -&gt; <code>Ctrl+c</code>终止它</li><li>退出终端时：在新终端连接中，找到PID号，kill它</li></ul><h1 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h1><p>简介：</p><p>tmux可以在后台新建一个终端，并且用户退出后创建的终端仍然存在</p><p>用法：</p><ul><li>创建session</li></ul><p><code>tmux new -s $session_name</code></p><ul><li>列出session</li></ul><p><code>tmux ls</code></p><ul><li>临时退出session</li></ul><p><code>Ctrl+b d</code> </p><ul><li>进入已存在的session</li></ul><p><code>tmux a -t $session_name</code></p><ul><li>删除指定session</li></ul><p><code>tmux kill-session -t $session_name</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>&amp;  简单，安全，退出终端，程序自动结束</p></li><li><p>nohup 退出终端后，必须通过pid号杀程序</p></li><li><p>tmux 谁用谁知道，一般情况，时间长的程序，我都用它 </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;让命令在后台跑起来！&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>用jupyter notebook打开服务器（告别黑框框)</title>
    <link href="http://yoursite.com/2019/04/11/%E7%94%A8jupyter-notebook%E6%89%93%E5%BC%80%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%91%8A%E5%88%AB%E9%BB%91%E6%A1%86%E6%A1%86/"/>
    <id>http://yoursite.com/2019/04/11/用jupyter-notebook打开服务器（告别黑框框/</id>
    <published>2019-04-11T07:19:52.000Z</published>
    <updated>2019-04-11T07:34:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>几步完成服务器内jupyter notebook的使用</p><a id="more"></a><h1 id="为啥要这样"><a href="#为啥要这样" class="headerlink" title="为啥要这样"></a>为啥要这样</h1><p>可以远程用浏览器看服务器的文件目录，以及各种jupyter的好处：直接改代码，调试，它内嵌的读图也是特别舒服。</p><h1 id="服务器安装jupyter-notebook"><a href="#服务器安装jupyter-notebook" class="headerlink" title="服务器安装jupyter notebook"></a>服务器安装jupyter notebook</h1><p>我是给服务器装了<a href="https://zouxxyy.github.io/2019/04/10/linux%E4%B8%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%89%E8%A3%85anaconda3-pytorch-fastai/#more" target="_blank" rel="noopener">anaconda</a>，然后就自带了jupyter notebook。</p><h1 id="配置jupyter-notebook"><a href="#配置jupyter-notebook" class="headerlink" title="配置jupyter notebook"></a>配置jupyter notebook</h1><ol><li>登陆服务器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@address_of_remote</span><br></pre></td></tr></table></figure><ol start="2"><li>生成配置文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jupyter notebook --generate-config</span><br></pre></td></tr></table></figure><p>该指令会自动创建这个：<code>~/.jupyter/jupyter_notebook_config.py</code></p><ol start="3"><li>生成密码</li></ol><p>打开python，创建密码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> notebook.auth <span class="keyword">import</span> passwd</span><br><span class="line">passwd()</span><br><span class="line">Enter password:</span><br><span class="line">Verify password:</span><br><span class="line"><span class="string">'sha1:xxxxxxxxxxxxxxxxxxxxxxx'</span></span><br></pre></td></tr></table></figure><p>把密码<code>&#39;sha1:xxxxxxxxxxxxxxxxxxxxxxx&#39;</code>复制下来</p><ol start="4"><li>修改配置文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.jupyter/jupyter_notebook_config.py</span><br></pre></td></tr></table></figure><p>加上下面这几行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.allow_remote_access = <span class="literal">True</span></span><br><span class="line">c.NotebookApp.ip = <span class="string">'*'</span></span><br><span class="line">c.NotebookApp.password = <span class="string">u'sha1:xxxxxxxxxxxxxxxxxxxx'</span> <span class="comment">#你的密码</span></span><br><span class="line">c.NotebookApp.open_browser = <span class="literal">False</span></span><br><span class="line">c.NotebookApp.port = <span class="number">8888</span></span><br></pre></td></tr></table></figure><ol start="5"><li>启动jupyter</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jupyter notebook</span><br></pre></td></tr></table></figure><h1 id="远程访问"><a href="#远程访问" class="headerlink" title="远程访问"></a>远程访问</h1><ul><li><p>方法一： </p><p>  本地浏览器访问<code>http://address_of_remote:8888</code> （此方法可能由于防火墙问题出现失败）</p></li><li><p>方法二： </p><ol><li><p>在本地终端中输入:</p><p><code>ssh username@address_of_remote -L127.0.0.1:1234:127.0.0.1:8888</code></p></li><li><p>本地浏览器访问<code>http://localhost:1234</code></p></li></ol></li></ul><p>看看效果，虚浮了。相逢恨晚，造化弄人啊～</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/11/16a0a4fa59021e90?w=1293&h=200&f=png&s=25969" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几步完成服务器内jupyter notebook的使用&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="jupyter" scheme="http://yoursite.com/tags/jupyter/"/>
    
  </entry>
  
  <entry>
    <title>linux下命令行安装anaconda3+pytorch+fastai</title>
    <link href="http://yoursite.com/2019/04/10/linux%E4%B8%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%89%E8%A3%85anaconda3-pytorch-fastai/"/>
    <id>http://yoursite.com/2019/04/10/linux下命令行安装anaconda3-pytorch-fastai/</id>
    <published>2019-04-10T12:53:35.000Z</published>
    <updated>2019-04-11T07:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>几步完成 anaconda3+pytorch+fastai 的安装</p><a id="more"></a><h1 id="为啥用anaconda"><a href="#为啥用anaconda" class="headerlink" title="为啥用anaconda"></a>为啥用anaconda</h1><p>anaconda 确实很好用，切换python版本也方便。而且如果服务器用的人多，用anaconda搞个自己的环境很舒服。</p><h1 id="anaconda3安装"><a href="#anaconda3安装" class="headerlink" title="anaconda3安装"></a>anaconda3安装</h1><ol><li><strong><a href="https://www.anaconda.com/distribution/" target="_blank" rel="noopener">官网</a>选择要下载的版本</strong>。我用的是python3.7做base（如果后面想用python2.7直接加个环境就行）</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a0537dfe227c8d?w=1122&h=485&f=png&s=62781" alt></p><p>把下载地址拷贝下来，用<code>wget</code>下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.anaconda.com/archive/Anaconda3-2019.03-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>安装</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash Anaconda3-2019.03-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><p>这个过程需要</p><ol><li>按回车阅读license，并同意</li><li>选择安装地址，我就是按默认的<code>/home/zxy/anaconda3</code></li><li>是否 conda init ，这步同意了会自动在<code>/home/zxy/.bashrc</code>改你的环境变量。</li></ol><ol start="3"><li><strong>激活环境变量的修改</strong> </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>激活下修改，就安装完毕了，然后可以rm掉安装包。</p><ol start="4"><li><strong>一些细节</strong></li></ol><p>同意了<code>conda init</code>后，会<strong>自动</strong>在<code>/home/zxy/.bashrc</code>加下面这些东西。可以用<code>cat ~/.bashrc</code>自己看看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt;&gt;&gt; conda initialize &gt;&gt;&gt;</span></span><br><span class="line"><span class="comment"># !! Contents within this block are managed by 'conda init' !!</span></span><br><span class="line">__conda_setup=<span class="string">"<span class="variable">$('/home/zxy/anaconda3/bin/conda' 'shell.bash' 'hook' 2&gt; /dev/null)</span>"</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="string">"<span class="variable">$__conda_setup</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="string">"/home/zxy/anaconda3/etc/profile.d/conda.sh"</span> ]; <span class="keyword">then</span></span><br><span class="line">        . <span class="string">"/home/zxy/anaconda3/etc/profile.d/conda.sh"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">export</span> PATH=<span class="string">"/home/zxy/anaconda3/bin:<span class="variable">$PATH</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">unset</span> __conda_setup</span><br><span class="line"><span class="comment"># &lt;&lt;&lt; conda initialize &lt;&lt;&lt;</span></span><br></pre></td></tr></table></figure><p>有了它呢，我们直接<code>python</code>测试看看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) [zxy@gpu-server5 ~]$ python</span><br><span class="line">Python 3.7.3 (default, Mar 27 2019, 22:11:17) </span><br><span class="line">[GCC 7.3.0] :: Anaconda, Inc. on linux</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> or <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br></pre></td></tr></table></figure><p>OK! 可以用了！</p><h1 id="pytorch安装"><a href="#pytorch安装" class="headerlink" title="pytorch安装"></a>pytorch安装</h1><p> <strong><a href="https://pytorch.org/" target="_blank" rel="noopener">官网</a>选择下载的版本</strong>。这里要根据自己的cuda版本选择</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/10/16a0535a5d05c267?w=825&h=316&f=png&s=40869" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision cudatoolkit=9.0 -c pytorch</span><br></pre></td></tr></table></figure><p>因为有了<code>anaconda</code>，安装<code>pytorch</code>一句话完事。</p><p>(ps：国内兄弟，可以先添加<a href="https://mirror.tuna.tsinghua.edu.cn/help/anaconda/" target="_blank" rel="noopener">清华镜像</a>，再把后面的-c pytorch去掉。速度飞起～)</p><h1 id="fastai安装"><a href="#fastai安装" class="headerlink" title="fastai安装"></a>fastai安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c fastai fastai</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几步完成 anaconda3+pytorch+fastai 的安装&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="anaconda" scheme="http://yoursite.com/tags/anaconda/"/>
    
  </entry>
  
  <entry>
    <title>JVM(8)-虚拟机字节码执行引擎</title>
    <link href="http://yoursite.com/2019/03/29/JVM-8-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>http://yoursite.com/2019/03/29/JVM-8-虚拟机字节码执行引擎/</id>
    <published>2019-03-29T08:51:23.000Z</published>
    <updated>2019-03-29T08:53:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是《深入理解Java虚拟机（第二版）》第八章的笔记</p><a id="more"></a><h1 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h1><p>在活动线程中，只有栈顶的栈时有效的，称为<strong>当前栈帧</strong>，与这个栈帧相关联的方法称为<strong>当前方法</strong>。下面对栈帧的4个主要部分进行分析。</p><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>存放方法参数和方法内部定义的局部变量</p><p>一些细节：</p><ul><li>最小存储单元(Slot)，一个Slot可以存32位以内的数据类型。</li><li><code>boolean、byte、char、short、int、float、reference、returnAddress</code>占一个Slot；<code>long、double</code>占两个Slot，是非原子的，但它是<strong>线程安全</strong>的，因为它是栈中的，是线程私有的。</li><li>对于实例方法，第一个Slot是传递所属对象实例的引用，也就是我们常用的   <code>this</code>。</li><li>注意局部变量<strong>没有初始值</strong>哦。</li><li>当一个变量的pc寄存器的值大于Slot的作用域时，Slot是可以<strong>复用</strong>的。</li></ul><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><ul><li>虚拟机字节码执行引擎是“<strong>基于栈的执行引擎</strong>”，这个栈就是操作数栈。</li><li>对比<strong>基于寄存器</strong>的执行引擎</li></ul><p>优点：可移植性、代码更加紧凑、编译器实现更紧凑。确定就是速度更慢。</p><ul><li>下面栈帧的部分操作数栈与上面的栈帧的部分局部变量是重叠的。</li></ul><h2 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h2><p>指向运行时常量池中该栈帧所属方法的引用，这个引用的为了支持方法调用过程的动态连接。具体内容在下面的方法调用中解释。</p><h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>方法退出（也就是<strong>当前栈帧出栈</strong>）的两种方式：</p><ul><li><code>return</code>正常退出</li><li>异常退出，根据异常表得返回出口</li></ul><h1 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h1><p>方法调用不等同于方法的执行，方法调用阶段唯一的任务就是确定被调用方法的版本。说白了就是找方法，方法唯一就直接确定（<strong>解析</strong>）。方法不唯一：<strong>重载（静态分配）、重写（动态分配）</strong></p><h2 id="解析调用"><a href="#解析调用" class="headerlink" title="解析调用"></a>解析调用</h2><ul><li><p>调用目标在程序代码写好、编译器进行编译时就确定好的。这类方法时调用称为解析。是静态的。</p></li><li><p><strong>非虚方法</strong>：静态方法、私有方法、实例构造器、父类方法、final方法。它们都是采用解析调用。反之其它就是虚方法。</p></li></ul><h2 id="分派调用"><a href="#分派调用" class="headerlink" title="分派调用"></a>分派调用</h2><p><code>Human man = new Man();</code></p><p><code>Human</code>是静态类型（外观类型），<code>Man</code>是实际类型</p><h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p>依赖静态类型来定位方法执行的版本的分配动作称为静态分配。最典型的应用是方法重载。</p><ul><li>编译器在<strong>重载</strong>时是根据参数的<strong>静态类型</strong>作为依据的。</li><li>由于字面量没有显式的静态类型，它重载时可能会有多种选择，只是选一个更好的版本。</li><li>静态分配和解析不是互斥的，例如静态方法也是可以重载的。</li><li>注意：静态分配更严格，<strong>一定是要用静态类型做参数</strong>。</li></ul><h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p>依赖实际类型来定位方法执行的版本的分配动作称为动态分配。最典型的应用是方法重写。</p><ul><li>虚拟器在<strong>重写</strong>时是对象的<strong>实际类型</strong>作为依据的。</li><li>注意：动态分配更宽松，如果实际类型中没有对应的方法，就会向上找父类里的相同方法来调用。</li></ul><p>一个测试例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MixTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123; &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">choice</span><span class="params">(Human arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose human"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">choice</span><span class="params">(Man arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose man"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">choice</span><span class="params">(Woman arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose woman"</span>); <span class="comment">// 和同一类里的同名方法是重载关系</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">choice</span><span class="params">(Human arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose human"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">choice</span><span class="params">(Man arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose man"</span>); <span class="comment">// 和父类的同名同参数方法是重写关系</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">choice</span><span class="params">(Woman arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose woman"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        Man man = <span class="keyword">new</span> Man();</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Father son = <span class="keyword">new</span> Son();</span><br><span class="line">        father.choice(woman); <span class="comment">// 重写：对象类型选Father(实际类型) 重载：参数类型选 Human（静态类型）</span></span><br><span class="line">        son.choice(man); <span class="comment">// 重写：对象类型选Son(实际类型) 重载：参数类型选 Man（静态类型）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 程序输出：</span></span><br><span class="line"><span class="comment">father choose human</span></span><br><span class="line"><span class="comment">son choose man</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《深入理解Java虚拟机（第二版）》第八章的笔记&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM(7)-虚拟机类加载机制</title>
    <link href="http://yoursite.com/2019/03/29/JVM-7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/03/29/JVM-7-虚拟机类加载机制/</id>
    <published>2019-03-29T08:51:13.000Z</published>
    <updated>2019-03-29T08:52:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是《深入理解Java虚拟机（第二版）》第七章的笔记</p><a id="more"></a><h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><p>类加载后要初始化。所以可以通过判断啥时候要<strong>初始化</strong>，得出类加载的时机。</p><h2 id="有且只有5种情况需要对类进行初始化"><a href="#有且只有5种情况需要对类进行初始化" class="headerlink" title="有且只有5种情况需要对类进行初始化"></a><strong>有且只有5种情况</strong>需要对类进行初始化</h2><ol><li><code>new</code>实例化对象、读取或设置静态字段（被<strong>final修饰放入常量池</strong>时除外）、调用类的静态方法 （且类没有初始化）。</li><li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用，且类没有初始化</li><li>初始化一个类时，如果父类没有初始化，会触发父类的初始化</li><li>含main方法的类会优先初始化</li><li>当使用JDK1.7的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果<code>REF_getStatic、REF_pubStatic、REF_invokeStatic</code>的方法句柄，并且这个句柄对应的类没有初始化，会触发其初始化。（黑人问号。。）</li></ol><h2 id="被动引用的例子"><a href="#被动引用的例子" class="headerlink" title="被动引用的例子"></a>被动引用的例子</h2><ul><li>用子类引用父类的静态字段<code>SubClass.value</code>(value在父类中)，只会初始化父类。</li><li>通过数组来定义引用类，不会触发次类的初始化</li><li><code>final</code>修饰的静态常量会存入常量池，引用它不会触发初始化(可以与上面的第一种情况比较)</li></ul><h2 id="与接口初始化的比较"><a href="#与接口初始化的比较" class="headerlink" title="与接口初始化的比较"></a>与接口初始化的比较</h2><ul><li>接口不能使用static{}语句块，但有<code>&lt;clinit&gt;()</code>类构造器</li><li>与第三条不同：初始化一个接口时，如果父类接口没有初始化，父类接口不会初始化。</li></ul><h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><p><img src="https://user-gold-cdn.xitu.io/2019/3/28/169c226c3ad50652?w=1339&h=609&f=png&s=39162" alt></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>在加载期间虚拟机完成以下三件事：</p><ul><li>通过类的全限定名获取定义此类的二进制字节流</li><li>通过这个二进制流代表的静态存储结构转化为方法区的运行时数据</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口（HotSpot虚拟机中Class对象是 在方法区中）<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2></li><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为类的变量（<strong>static修饰</strong>）分配内存并设置变量的初始值。这些变量所用的内存都在方法区中分配。</p><p>注意：这里的初始值是其<strong>默认值</strong>。如果是<code>static final</code>修饰，就初始化为指定值，存在常量区。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>将虚拟机中的<strong>符号引用</strong>替换为<strong>直接引用</strong></p><p>主要的解析动作</p><ul><li>类或者接口的解析</li><li>字段解析</li><li>类方法的解析</li><li>接口方法的解析</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>执行<code>&lt;clinit&gt;()</code>方法的过程。和<code>&lt;init&gt;()</code>比较下：</p><ul><li><code>&lt;clinit&gt;()</code>：类的初始化，类变量的赋值动作和静态语句块合并一起。</li><li><code>&lt;init&gt;()</code>：类的实例化，也就是类的构造方法。初始化实例用的。</li></ul><p>一些细节：</p><ul><li><p>定义在静态语句块后面的变量，静态语句块可以赋值但不能访问。如果访问会报错“<strong>非法前向引用</strong>”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Clinit &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        i = 0;</span><br><span class="line">        // System.out.println(i); // 非法前向引用</span><br><span class="line">    &#125;</span><br><span class="line">    static int i = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优先执行父类的<code>&lt;clinit&gt;()</code>方法</p></li><li><p>接口的父类<code>&lt;clinit&gt;()</code>方法不需要先执行，并且接口的实现类在初始化时也不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p></li><li><p>如果多个线程同时初始化一个类，只有一个线程会执行类的<code>&lt;clinit&gt;()</code>方法。</p></li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>类加载器干的事：通过类的全限定名获取定义此类的二进制字节流。只有被同一个类加载器所加载的类才有可能相等。</p><p>优势：<strong>类层次划分</strong>、OSGi、热部署、<strong>代码加密</strong> 等等。</p><p>类加载器分类</p><ul><li>启动类加载器：c++实现，是虚拟机等一部分，加载<code>&lt;JAVA_HOME&gt;/lib</code>目录下的类</li><li>扩展类加载器：加载<code>&lt;JAVA_HOME&gt;/lib/ext</code>目录下的类</li><li>应用程序类加载器：加载用户路径上指定的类库</li><li>自定义类加载器：用户自定义的类加载器</li></ul><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p><img src="https://user-gold-cdn.xitu.io/2019/3/28/169c226f3fdffe17?w=468&h=359&f=png&s=122552" alt></p><ul><li>要求：除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。</li><li>过程：就是把加载的活<strong>推拖</strong>给父类加载器，一直推到最顶层。然后让最顶层加载器加载，如果它干不了，再递给子，直到推给发起者，如果它也干不了，就发出 <code>ClassNotFoundException</code>异常。</li><li>优点：使类有类层次性。如在双亲委派模型下，Object类是由最顶层的启动类加载器加载，所以它在每种加载器中都是同一个类，使Object这一最基础的类的性能得以保证。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《深入理解Java虚拟机（第二版）》第七章的笔记&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM(4)-虚拟机性能监控与故障处理工具</title>
    <link href="http://yoursite.com/2019/03/25/JVM-4-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2019/03/25/JVM-4-虚拟机性能监控与故障处理工具/</id>
    <published>2019-03-25T09:14:42.000Z</published>
    <updated>2019-03-25T09:15:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是《深入理解Java虚拟机（第二版）》第四章的笔记</p><a id="more"></a><p>我的JDK工具地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">zxysMac:~ elwg$ <span class="built_in">cd</span> /Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/bin</span><br><span class="line">zxysMac:bin elwg$ ls</span><br><span class="line">appletviewerjavahjjsjvisualvmschemagen</span><br><span class="line">extcheckjavapjmapkeytoolserialver</span><br><span class="line">idljjavapackagerjmcnative2asciiservertool</span><br><span class="line">jarjcmdjpsorbdtnameserv</span><br><span class="line">jarsignerjconsolejrunscriptpack200unpack200</span><br><span class="line">javajdbjsadebugdpolicytoolwsgen</span><br><span class="line">javacjdepsjstackrmicwsimport</span><br><span class="line">javadocjhatjstatrmidxjc</span><br><span class="line">javafxpackagerjinfojstatdrmiregistry</span><br></pre></td></tr></table></figure><h1 id="JDK的命令行工具"><a href="#JDK的命令行工具" class="headerlink" title="JDK的命令行工具"></a>JDK的命令行工具</h1><table><thead><tr><th>名称</th><th>全名</th><th>主要功能</th></tr></thead><tbody><tr><td>jps</td><td>JVM Process Status</td><td>显示指定系统的所有的虚拟机进程</td></tr><tr><td>jstat</td><td>JVM Statistics Monitoring Tool</td><td>用于收集虚拟机各方面的运行数据</td></tr><tr><td>jinfo</td><td>Configuration Info for Java</td><td>显示虚拟机配置信息</td></tr><tr><td>jmap</td><td>Memory Map for Java</td><td>生成虚拟机的内存转储快照（heapdump文件）</td></tr><tr><td>jhat</td><td>JVM Heap Dump Browser</td><td>用于分析heapdump文件</td></tr><tr><td>jstack</td><td>Stack Trace for Java</td><td>显示虚拟机的线程快照</td></tr><tr><td>## jps：虚拟机进程状况工具</td><td></td><td></td></tr><tr><td>- 功能：可以列出运行的虚拟机进程、看到虚拟机执行的主类、本地虚拟机唯一ID</td><td></td><td></td></tr></tbody></table><ul><li>命令格式：<br><code>jps [ option ] [ hostid ]</code></li><li>主要选项：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169a9a09b0013234?w=918&h=205&f=png&s=96305" alt></p><ul><li>例子：我在IDEA中运行列一个java文件，测试如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) zxysMac:~ elwg$ jps -l</span><br><span class="line">16387 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class="line">44422 sun.tools.jps.Jps</span><br><span class="line">44392 com.zouxxyy.jvm.chap4.JpsTest</span><br><span class="line">31368 org.jetbrains.kotlin.daemon.KotlinCompileDaemon</span><br><span class="line">16217</span><br><span class="line">44393 org.jetbrains.jps.cmdline.Launcher</span><br></pre></td></tr></table></figure></li></ul><h2 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h2><ul><li>功能：可以显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</li><li>命令格式：<code>jstat [ option vmid [interval[s|ms] [count]] ]</code></li><li>主要选项：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169a9aa3cfd87699?w=923&h=459&f=png&s=275718" alt></p><h2 id="jinfo：Java配置信息工具"><a href="#jinfo：Java配置信息工具" class="headerlink" title="jinfo：Java配置信息工具"></a>jinfo：Java配置信息工具</h2><ul><li><p>功能：实时查看和调整虚拟机各项参数</p></li><li><p>命令格式：<code>jinfo [ option ] pid</code></p></li><li><p>例子：看有没有用SerialGC</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) zxysMac:~ elwg$ jinfo -flag UseSerialGC 46521</span><br><span class="line">-XX:-UseSerialGC</span><br></pre></td></tr></table></figure><h2 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h2><ul><li>功能：生成虚拟机堆存转储快照（heapdump文件）</li><li>命令格式：<code>jmap [ option] vmid</code></li><li>主要选项：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169a9b5409980aff?w=933&h=403&f=png&s=202391" alt></p><h2 id="jhat：虚拟机堆快照分析工具"><a href="#jhat：虚拟机堆快照分析工具" class="headerlink" title="jhat：虚拟机堆快照分析工具"></a>jhat：虚拟机堆快照分析工具</h2><p>与jmap配合使用，也就是分析堆存转储快照（heapdump文件）。</p><h2 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h2><ul><li>功能：用于生成虚拟机的线程快照</li><li>命令格式：<code>jstack [ option ] vmid</code></li><li>主要选项：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169a9b95790bdcd5?w=920&h=188&f=png&s=81541" alt></p><h1 id="JDK的可视化工具"><a href="#JDK的可视化工具" class="headerlink" title="JDK的可视化工具"></a>JDK的可视化工具</h1><h2 id="JConsole：Java监视与管理控制台"><a href="#JConsole：Java监视与管理控制台" class="headerlink" title="JConsole：Java监视与管理控制台"></a>JConsole：Java监视与管理控制台</h2><p><strong>内存监控，相当于可视化的<code>jstat</code>命令</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b291ef7f36929?w=858&h=628&f=png&s=106536" alt><br><strong>线程监控，相当于可视化的<code>jstack</code>命令</strong>，以下举几个简单的例子</p><ul><li>监听用户键盘输入</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b2a74ba142acd?w=811&h=134&f=png&s=29000" alt></p><ul><li>监听wait()</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b2a7c8556a816?w=819&h=206&f=png&s=45681" alt></p><ul><li>监听死锁</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b2bdcdb14d52d?w=844&h=306&f=png&s=35573" alt></p><h2 id="VisualVM：多合一故障处理工具"><a href="#VisualVM：多合一故障处理工具" class="headerlink" title="VisualVM：多合一故障处理工具"></a>VisualVM：多合一故障处理工具</h2><p>书上说它很强大，我还没下载成功。它几乎集成里上面的所有功能啊。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b2e570ebb1cc5?w=1239&h=665&f=png&s=126621" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《深入理解Java虚拟机（第二版）》第四章的笔记&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM(3)-垃圾收集器与内存分配策略</title>
    <link href="http://yoursite.com/2019/03/25/JVM-3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2019/03/25/JVM-3-垃圾收集器与内存分配策略/</id>
    <published>2019-03-25T09:14:12.000Z</published>
    <updated>2019-03-25T09:15:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是《深入理解Java虚拟机（第二版）》第三章的笔记</p><a id="more"></a><h1 id="如何判断对象为垃圾对象"><a href="#如何判断对象为垃圾对象" class="headerlink" title="如何判断对象为垃圾对象"></a>如何判断对象为垃圾对象</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>给对象添加一个引用计数器，每当有个对象引用它时，计数器加1；引用失效时计数器减1；为0时对象不可能被再引用。</p><p>没有使用的原因：很难解决<strong>对象之间相互循环引用</strong>的问题</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>看作为GC Roots的对象作为起始点，和<strong>它连通的是可用的，反之不可用</strong>。</p><p>如下情况的对象可以作为GC Roots：</p><ul><li>虚拟机栈(栈桢中的本地变量表)、本地方法栈中JNI（Native方法）中的引用的对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><p>当对象不可达时，会执行<code>fianlize()</code>，但该方法自会被自动调用一次，有点像c++的析构函数，书上说最好别用。</p><h2 id="引用的分类"><a href="#引用的分类" class="headerlink" title="引用的分类"></a>引用的分类</h2><ul><li>强引用：<code>Objece obj = new Object()</code>，永远不会被垃圾搜集回收</li><li>软引用：<code>SoftReference</code>类实现，可以存活第一次回收，但第二次就GG</li><li>弱引用：<code>WeakReference</code>类实现，第一次就GG</li><li>虚引用：<code>PhantomReference</code>类实现，<strong>不能通过它取得实例</strong>，唯一作用就是当该对象被回收时会收到一个系统通知。<h1 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h1><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2></li><li>标记-清除算法：（老年代）先标记，再清除。缺点：效率低，内存碎片化</li><li>复制算法：（新生代）HotSpot虚拟机把内存分为Eden和2块Survivor区，把在Eden和Survivor中 存活的对象 复制到空闲的一块Survivor中。不够时可以向老年代担保。</li><li>标记-整理算法：（老年代）标记 -&gt; 移动到一起 -&gt; 清理</li><li>分代收集算法：把内存分为新生代和老年代。根据年代选则合适的算法。<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2></li></ul><table><thead><tr><th>新生代</th><th>老年代</th><th>特殊</th></tr></thead><tbody><tr><td>Serial（单线程）</td><td>Serial Old（单线程，CMS备胎）</td><td>G1（Region优先级回收）</td></tr><tr><td>ParNew（多线程）</td><td>CMS（并发）</td><td></td></tr><tr><td>Parallel Scavenge（关注吞吐量）</td><td></td><td></td></tr><tr><td>- 并行（Parallel）：多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。</td><td></td><td></td></tr><tr><td>- 并发（Concurrent）：用户线程与垃圾收集线程同时执行。</td><td></td><td></td></tr><tr><td># 如何分配</td><td></td><td></td></tr><tr><td>以HosSpot收集器的分配和回收策略为例</td><td></td><td></td></tr><tr><td>- 优先分配在Eden</td><td></td><td></td></tr><tr><td>- <strong>大对象直接进入老年代</strong></td><td></td><td></td></tr><tr><td>- 长期存活的对象进入老年代</td><td></td><td></td></tr><tr><td>- 动态对象年龄判定</td><td></td><td></td></tr><tr><td>- 空间分配担保</td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《深入理解Java虚拟机（第二版）》第三章的笔记&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA 实用快捷键(持续更新)</title>
    <link href="http://yoursite.com/2019/03/22/IntelliJ-IDEA-%E5%AE%9E%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2019/03/22/IntelliJ-IDEA-实用快捷键-持续更新/</id>
    <published>2019-03-22T03:39:12.000Z</published>
    <updated>2019-03-22T03:42:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>IntelliJ IDEA 的小技巧，持续更新哦</p><a id="more"></a><h1 id="码代码"><a href="#码代码" class="headerlink" title="码代码"></a>码代码</h1><h2 id="1-缩写功能"><a href="#1-缩写功能" class="headerlink" title="1. 缩写功能"></a>1. <strong>缩写功能</strong></h2><ul><li><p>方式：一般取首字母即可</p></li><li><p>例子 ：</p></li></ul><p><code>public static void main(String[] args){}</code>可以用 <code>psvm</code>出来<br><img src="https://user-gold-cdn.xitu.io/2019/3/20/1699af88700b10ec?w=659&h=78&f=png&s=15782" alt><br><code>System.out.printf(&quot;&quot;);</code>可以用 <code>souf</code>打出来<br><img src="https://user-gold-cdn.xitu.io/2019/3/20/1699afa70d8e05ee?w=536&h=58&f=png&s=14067" alt>`</p><h2 id="2-创建新函数"><a href="#2-创建新函数" class="headerlink" title="2. 创建新函数"></a>2. <strong>创建新函数</strong></h2><ul><li><p>方式： 选中目标函数，<code>alt + enter</code> 即可</p></li><li><p>例子：</p></li></ul><p>要加的函数：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/20/1699b0142ecd3d26?w=571&h=65&f=png&s=12515" alt><br>生成的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">newfun</span><span class="params">(<span class="keyword">int</span> i, String aa)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-加-surround，如if、catch"><a href="#3-加-surround，如if、catch" class="headerlink" title="3. 加 surround，如if、catch"></a>3. <strong>加 surround，如if、catch</strong></h2><ul><li><p>方式： 选中目标代码段，<code>ctrl + alt + t</code> 再选择surround类型</p></li><li><p>例子：</p></li></ul><p>要加的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">300</span>);</span><br></pre></td></tr></table></figure><p>选中，再<code>ctrl + alt + t</code>：<br><img src="https://user-gold-cdn.xitu.io/2019/3/20/1699b0a77552c0f9?w=666&h=421&f=png&s=62639" alt><br>添加后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IntelliJ IDEA 的小技巧，持续更新哦&lt;/p&gt;
    
    </summary>
    
      <category term="其它" scheme="http://yoursite.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="IDEA" scheme="http://yoursite.com/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>JVM(2)-Java内存区域与内存溢出异常</title>
    <link href="http://yoursite.com/2019/03/22/JVM-2-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2019/03/22/JVM-2-Java内存区域与内存溢出异常/</id>
    <published>2019-03-22T03:38:21.000Z</published>
    <updated>2019-03-22T06:49:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是《深入理解Java虚拟机（第二版）》第二章的笔记</p><a id="more"></a><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/1699e42932e70b62?w=652&h=625&f=png&s=45434" alt><br>我们这节关注中间灰色部分，注意绿色部分<strong>线程共享</strong>，黄色部分<strong>线程私有</strong></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>一块较小的内存，是<strong>当前线程</strong>（线程私有）执行的字节码的<strong>行号指示器</strong>。</p><ul><li>如果执行的是Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果是Native（本地方法），计数器值为空(Undefined)</li><li>唯一没有<code>OutOfMemoryError</code>的区域</li></ul><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>虚拟机栈是描述Java方法执行的内存模型</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/1699f1c41f3b3ba5?w=551&h=419&f=png&s=23533" alt><br>每个方法调用至完成，对应一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>局部变量表：</p><ul><li>存放<strong>基本数据类型</strong>、<strong>对象引用</strong>、<strong>returnAddress</strong></li><li>局部变量表所需的内存空间在<strong>编译期</strong>完成，该空间是确定的，方法运行期间<strong>不改变</strong>。</li></ul><p>两种异常：</p><ul><li><code>StackOverflowError</code>: 请求的栈深度超过允许范围</li><li><code>OutOfMemoryError</code>: 需要的内存超过允许范围<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2>本地方法栈是描述<strong>本地方法</strong>执行的内存模型。它和Java虚拟机栈很类似，区别就是它是为本地方法服务的。<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2>存放对象示例，也称作（GC堆），是垃圾回收器管理的主要区域。</li><li>细分 新生代、老生代；Eden空间、From Survivor空间、To Survivor空间等</li><li>线程共享的堆里可能划分出私有的分配缓冲区（TLAB）。<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2>存储<strong>已被虚拟机加载的类信息</strong>、常量、静态变量、即时编译后的代码等数据。</li></ul><p><strong>运行时常量池</strong> ：<br>存放编译器生成的各种字面常量和符号引用。</p><p>例子：String类在常量池的数据结构类似于HashSet,是唯一的。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/169a02588d5caac4?w=612&h=354&f=png&s=27965" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"abc"</span>; <span class="comment">// 存放在方法区的常量池（字节码常量）唯一</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">// 用了new，所以在堆中创建</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s3); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s3.intern()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注意哦jdk1.8 String常量池搬到了堆中。如果想对<code>intern()</code>了解更多，可以看我的这篇<a href="https://zouxxyy.github.io/2019/03/22/JDK1-8-String%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/#more" target="_blank" rel="noopener">博客</a>。</p><h1 id="HotSpot对象揭秘"><a href="#HotSpot对象揭秘" class="headerlink" title="HotSpot对象揭秘"></a>HotSpot对象揭秘</h1><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>对象创建简单描述：</p><p>new -&gt; 根据常量池中符号看是否需要加载 -&gt; 类加载 -&gt; 分配内存 -&gt; 初始化 -&gt;构造方法</p><p>给对象分配内存的两种方法：</p><ul><li>指针碰撞</li><li>空闲列表</li></ul><p>解决创建对象时线程安全问题两种方法：</p><ul><li>分配内存动作进行同步处理</li><li>TLAB（共享堆中按线程划分的线程私有部分）上分配，它分配完，再同步锁定</li></ul><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>3块区域：</p><ul><li><p>对象头</p><ul><li><p>自身运行时的数据（MarkWord）：HashCode、GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳等</p></li><li><p>类型指针：对象指向它的类元数据的指针，虚拟机可以根据它来确定该对象是哪个类的实例。</p><p>注意如果对象是数组，那么对象头中还有一块用于记录数组长度的数据。</p></li></ul></li><li><p>实例数据</p></li><li><p>对齐填充 ：当实例部分没对齐时，通过对齐填充来补全</p></li></ul><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><ul><li>句柄访问（2级指针）</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/169a038a164fdc67?w=604&h=404&f=png&s=33178" alt><br>可以看出来要到实例数据必须再经过一个指针，这么做到好处是，当对象移动时，我们只需要改变局柄池里的指针，不需要改变reference；缺点是速度慢。</p><ul><li>直接指针</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/169a038c26fd8733?w=602&h=408&f=png&s=28283" alt><br>直接指针顾名思义直接指向实例数据，好处是速度快；缺点就是对象移动要改reference。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《深入理解Java虚拟机（第二版）》第二章的笔记&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8 String常量池详解</title>
    <link href="http://yoursite.com/2019/03/22/JDK1-8-String%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/03/22/JDK1-8-String常量池详解/</id>
    <published>2019-03-22T03:25:08.000Z</published>
    <updated>2019-03-22T03:29:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 JDK1.8 String常量池详解，带图哦</p><a id="more"></a><p><strong>jdk 1.8</strong></p><h1 id="先抛结论"><a href="#先抛结论" class="headerlink" title="先抛结论"></a>先抛结论</h1><h2 id="1-只在常量池上创建常量"><a href="#1-只在常量池上创建常量" class="headerlink" title="1.只在常量池上创建常量"></a>1.只在常量池上创建常量</h2><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a32568b4c1f09?w=531&h=366&f=png&s=15995" alt></p><h2 id="2-只在堆上创建对象"><a href="#2-只在堆上创建对象" class="headerlink" title="2.只在堆上创建对象"></a>2.只在堆上创建对象</h2><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a32d01c0c56b4?w=577&h=389&f=png&s=19131" alt></p><h2 id="3-在堆上创建对象，在常量池上创建常量"><a href="#3-在堆上创建对象，在常量池上创建常量" class="headerlink" title="3.在堆上创建对象，在常量池上创建常量"></a>3.在堆上创建对象，在常量池上创建常量</h2><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a32fd14b320a8?w=553&h=362&f=png&s=18505" alt></p><h2 id="4-在堆上创建对象，在常量池上创建引用"><a href="#4-在堆上创建对象，在常量池上创建引用" class="headerlink" title="4.在堆上创建对象，在常量池上创建引用"></a>4.在堆上创建对象，在常量池上创建引用</h2><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a331a8ed3ecb4?w=561&h=362&f=png&s=20883" alt></p><p>注意：</p><ul><li><p>常量池有两种情况：引用（指针） 或 常量。<strong>如果该位置已经是引用或常量了，之后的操作都不会改变里面的情况！！！</strong></p></li><li><p>调用<code>intern()</code>（jdk1.8）: <strong>如果常量池里是空的，就创建引用（指向堆，参考结论4）；非空，不操作。返回值都是常量池里的内容。</strong></p></li><li><p>堆中可以有任意个相同的字符串，常量池只能有一个（引用 或 常量）。</p></li><li><p>“ “ 和intern() 其实很像。区别就是在常量池为空时，“ ”是把值加进去，intern()是把引用加进去。</p></li></ul><h1 id="根据结论解决例子"><a href="#根据结论解决例子" class="headerlink" title="根据结论解决例子"></a>根据结论解决例子</h1><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"zxy"</span>);    <span class="comment">// 结论3</span></span><br><span class="line">s1.intern(); <span class="comment">// 常量池非空，返回值是常量池里的内容</span></span><br><span class="line">String s2 = <span class="string">"zxy"</span>; <span class="comment">// 常量池非空，返回值是常量池里的内容</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1.intern() == s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a351b50cc98d6?w=569&h=355&f=png&s=18514" alt></p><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"zxy"</span>; <span class="comment">// 加到常量池</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"zxy"</span>); <span class="comment">// 加到堆，常量池有东西所以啥也不干</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">System.out.println(s1 == s2.intern()); <span class="comment">// true 常量池非空，intern返回常量池里的内容</span></span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/3/22/169a35d23404be5b?w=468&h=373&f=png&s=16487" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是 JDK1.8 String常量池详解，带图哦&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>java多线程编程chap5-7</title>
    <link href="http://yoursite.com/2019/03/14/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8Bchap5-7/"/>
    <id>http://yoursite.com/2019/03/14/java多线程编程chap5-7/</id>
    <published>2019-03-14T02:54:58.000Z</published>
    <updated>2019-03-14T02:58:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是《java多线程编程核心技术》第五、六、七章的学习笔记。</p><a id="more"></a><h1 id="定时器-Timer"><a href="#定时器-Timer" class="headerlink" title="定时器 Timer"></a>定时器 Timer</h1><p>Timer类主要负责计划任务的功能</p><p>一些方法：</p><ul><li><code>schedule(TimerTask task, Date time)</code> 在指定的日期执行某一次任务。</li><li><code>schedule(TimerTask task, long delay)</code>    以执行此方法的当前时间为参考时间，在此时间基础上延迟指定的毫秒数后执行一次TimerTask任务</li><li><code>schedule(TimerTask task, long delay, long period)</code>    以执行此方法的当前时间为参考时间，在此时间基础上延迟指定的毫秒数，再以某一间隔时间无限次数地执行某一TimerTask任务</li><li><code>scheduleAtFixedRate(TimerTask task, Date firstTime, long period)</code>    在指定的日期之后，按指定的间隔周期，无限循环的执行某一任务</li></ul><p><code>schedule</code>和<code>scheduleAtFixedRate</code>的异同：</p><p>同：</p><ul><li>多次调用<code>schedule</code>或<code>scheduleAtFixedRate</code>执行多个任务的话，则都是以队列的方式一个一个的被顺序执行。所以不用考虑非线程安全的问题。</li><li>如果任务延时了，那么下一次任务的执行时间都是上一次任务结束的时间（都带<code>period</code>参数时）</li></ul><p>异：</p><ul><li>不延时时，<code>schedule</code>下一次任务的执行时间是上一次任务开始加上<code>period</code>的时间，<code>scheduleAtFixedRate</code>下一次任务的执行时间是上一次任务结束的时间。</li></ul><h1 id="单例模式与多线程"><a href="#单例模式与多线程" class="headerlink" title="单例模式与多线程"></a>单例模式与多线程</h1><p>单例模式是23个设计模式中的一种，本章将它与多线程结合考虑</p><ul><li>立即加载/“饿汉模式”：调用方法前，实例已经被创建了。</li><li>延迟加载/“懒汉模式”：调用get()方法时实例才被创建。最常见的实现办法是在get()方法中进行new实例化。可是在多线程环境中会出问题，即创建多个实例。</li></ul><p>解决方案</p><ul><li><p>声明synchronized关键字，但运行效率非常低</p></li><li><p>同步代码块，但效率也非常低</p></li><li><p>针对某些重要代码单独的同步，效率提升，但是会创建多个实例</p></li><li><p>使用DCL双检查锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyObject myObject = <span class="keyword">new</span> MyObject();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyObject</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyObject <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (MyObject.class) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (myObject == <span class="keyword">null</span>) myObject = <span class="keyword">new</span> MyObject();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用静态内置类</p></li><li><p>使用static代码块</p></li><li><p>使用enum枚举数据类型</p></li></ul><h1 id="拾遗增补"><a href="#拾遗增补" class="headerlink" title="拾遗增补"></a>拾遗增补</h1><p>线程状态：<br><img src="https://user-gold-cdn.xitu.io/2019/3/14/16979f1bac8b4b94?w=843&h=634&f=png&s=182243" alt="方法与线程状态的转换图" title="方法与线程状态的转换图"><br>线程组：</p><ul><li>线程组中可以有线程对象，也可以有线程组，组中还可以有线程。作用是可批量管理线程或线程组对象，有效地对线程或线程组对象进行组织。</li><li>实例化一个线程组时如果不指定所属的线程组，它会自动归属到当前线程对象所属的线程组中。</li></ul><p>线程中出现异常的处理：</p><ul><li><code>setUncaughtExceptionHandler()</code>给指定线程对线设置异常处理器</li><li><code>setDefaultUncaughtExceptionHandler()</code>对指定线程类的所有线程对象设置异常处理器</li></ul><br><br><p><font size="6"><center><strong>完结撒花！</strong></center></font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《java多线程编程核心技术》第五、六、七章的学习笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java多线程编程chap3-4</title>
    <link href="http://yoursite.com/2019/03/13/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8Bchap3-4/"/>
    <id>http://yoursite.com/2019/03/13/java多线程编程chap3-4/</id>
    <published>2019-03-13T03:24:52.000Z</published>
    <updated>2019-03-13T03:25:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是《java多线程编程核心技术》第三、四章的学习笔记。</p><a id="more"></a><h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h2><p><code>wait()</code>和<code>notify()</code>: <code>wait</code>使线程停止运行，<code>notify</code>使停止的线程继续运行。</p><p>注意事项：</p><ul><li><code>wait()</code>自动锁放对象锁；<code>notify()</code>不释放；它们必须存在与同步块中。</li><li>wait 后线程会进入等待池，需要由同一对象的 notify 方法唤醒。</li><li>当线程处于wait状态时，调用<code>interrup()</code>方法会出现异常。</li><li>notify()随机唤醒线程，<code>notifyAll()</code>唤醒全部wait线程.</li><li><code>wait(n)</code>，使线程等待一段时间，如果没被唤醒，超过时间自动唤醒。 </li></ul><p>可以用<code>wait()</code>和<code>notify()</code>实现生产者和消费者</p><ul><li>假死：所有线程都呈WAITING状态。</li><li>原因：notify唤醒的是异类，如“生产者”唤醒“生产者”。</li><li>解决：将<code>notify()</code>改为<code>notifyAll()</code></li></ul><p>通过管道进行线程间通信：一个线程发送数据到输出管道，另一个线程从输入管道中读数据。</p><ul><li>字节流：<code>PipedInputStream</code>和<code>PipedOutputStream</code></li><li>字符流：<code>PipedReader</code>和<code>PipedWriter</code></li></ul><h2 id="方法join的使用"><a href="#方法join的使用" class="headerlink" title="方法join的使用"></a>方法join的使用</h2><p><code>join()</code>：使当前线程堵塞，等待线程对象销毁后，再执行当前线程后面的代码。</p><ul><li><code>join()</code>与<code>interrupt()</code>方法如果彼此遇到，则会出现异常。</li><li><code>join(long)</code>可设定等待的时间。注意：<code>join(long)</code>内部使用<code>wait(long)</code>实现，所以<code>join(long)</code>会<strong>释放锁</strong>；而<code>Thread.sleep(long)</code><strong>不会释放锁</strong>。</li></ul><h2 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h2><ul><li><code>ThreadLocal</code>类：让每个线程可以绑定自己的值</li><li>解决<code>get()</code>返回null的问题：覆盖    <code>initialValue()</code>方法使变量具有初始值。</li><li><code>InheritableThreadLocal</code>类可在子线程中取得父线程继承下来的值。</li><li>还可以对子线程继承下来的值进行修改。</li></ul><h1 id="Lock的使用"><a href="#Lock的使用" class="headerlink" title="Lock的使用"></a>Lock的使用</h1><h2 id="使用ReentrantLock类"><a href="#使用ReentrantLock类" class="headerlink" title="使用ReentrantLock类"></a>使用ReentrantLock类</h2><p>基本用法：</p><ul><li>同步： <code>lock()</code> 让线程持有了“对象监视器”，和synchronized一样，线程之间还是顺序执行的。</li><li>等待/通知： <code>condition.await()</code> 等待；<code>condition.siganl()</code>通知。注意调用<code>condition.await()</code>前须先调用<code>lock.lock()</code>。它比wait更灵活，因为它可以用不同的<code>condition</code>对象实现通知部分线程。</li></ul><p>公平锁和非公平锁</p><ul><li>公平锁： <code>new ReentranLock(true)</code> 获取锁是先进先得的</li><li>非公平锁： <code>new ReentranLock(false)</code> 获取锁是随机的</li></ul><p>一些方法：</p><ul><li><code>int getHoldCount()</code>    查询当前线程保持此锁定的个数，也就是调用lock()方法的次数。</li><li><code>int getQueueLength()</code>    返回正在等待获取此锁定的线程估计数</li><li><code>int getWaitQueueLength(Condition condition)</code>    返回等待与此锁定相关的给定条件Conditon的线程估计数</li><li><code>boolean hasQueueThread(Thread thread)</code>    查询指定的线程是否正在等待获取此锁定</li><li><code>boolean hasQueueThreads()</code>    查询是否有线程正在等待获取此锁定</li><li><code>boolean hasWaiters(Condition)</code>        查询是否有线程正在等待与此锁定有关的condition条件</li><li><code>boolean isFair()</code>    判断是不是公平锁</li><li><code>boolean isHeldByCurrentThread()</code>        查询当前线程是否保持此锁定</li><li><code>boolean isLocked()</code>    查询此锁定是否由任意线程保持</li><li><code>void lockInterruptibly()</code>    如果当前线程未被中断，则获取锁定，如果已经被中断则出现异常</li><li><code>boolean tryLock()</code>    仅在调用时锁定未被另一个线程保持的情况下，才获取该锁定</li><li><code>boolean tryLock(long timeout,TimeUnit unit)</code>    如果锁定在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁定</li><li><code>void awaitUninterruptibly()</code>    await状态时调用thread.interrupt()不会报错</li></ul><h2 id="使用ReentrantReadWriteLock类"><a href="#使用ReentrantReadWriteLock类" class="headerlink" title="使用ReentrantReadWriteLock类"></a>使用ReentrantReadWriteLock类</h2><p><code>ReentrantLock</code>类完全互斥，即同一时间只有一个线程可执行lock后面的任务。</p><p><code>ReentrantReadWriteLock</code>特点：</p><ul><li>读读共享</li><li>写写互斥</li><li>写读互斥</li><li>读写互斥</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《java多线程编程核心技术》第三、四章的学习笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java多线程编程chap1-2</title>
    <link href="http://yoursite.com/2019/03/11/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8Bchap1-2/"/>
    <id>http://yoursite.com/2019/03/11/java多线程编程chap1-2/</id>
    <published>2019-03-11T08:24:39.000Z</published>
    <updated>2019-03-11T08:27:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是《java多线程编程核心技术》第一、二章的学习笔记。</p><a id="more"></a><h1 id="第一章：Java多线程技能"><a href="#第一章：Java多线程技能" class="headerlink" title="第一章：Java多线程技能"></a>第一章：Java多线程技能</h1><h2 id="使用多线程"><a href="#使用多线程" class="headerlink" title="使用多线程"></a>使用多线程</h2><ul><li>实现多线程有两种方式：继承<code>Thread</code>类、实现<code>Runnable</code>接口</li><li><code>Thread.java</code>中的<code>start()</code>方法是异步执行，<code>thread.run</code>是同步；而且<code>start()</code>方法的顺序不代表线程启动的顺序，它是随机的。</li><li>在方法前加<code>synchronized</code>可以让线程安全。</li></ul><h2 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h2><ul><li><code>currentThread()</code> 返回代码段正在被哪个线程调用</li><li><code>isAlive()</code> 判断当前线程是否处于活动状态</li><li><code>sleep()</code> 让线程休眠</li><li><code>getID()</code> 获得线程的唯一标志</li><li><code>yield()</code> 让当前线程放弃cpu资源，但时间不确定</li></ul><h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><p>方式：</p><ul><li>使用退出标识，使线程正常退出，也就是当run方法完成后线程退出</li><li>使用interrupt方法中断线程</li></ul><p>第二种方式要注意：</p><ul><li><code>interrupt()</code> 实例方法，让线程中断，再用异常法检测中断使程序停止</li><li><code>interrupted()</code>是静态方法，测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false的功能。</li><li><code>isInterrupted()</code>是实例方法，测试Thread对象是否已经是中断状态，但不清除状态标志。</li><li>如果在sleep状态下停止某一线程，会进入catch语句（不需要判断是否中断），并且清除停止状态，使它变为false.</li></ul><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p><code>getPriority()</code>查看优先级，<code>setPriority()</code>设置优先级，有1～10级<br>线程优先级的特点：</p><ul><li>继承性: 如过线程A启动线程B，则B和A优先级一样</li><li>规则性: CPU尽量倾向于把资源优先级高的线程</li><li>随机性: 优先级不等同于执行顺序，优先级较高的不一定先执行完</li></ul><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>Java的线程分为两种：User Thread(用户线程)、Daemon Thread(守护线程)。</p><p>当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。Daemon作用是为其他线程提供便利服务，守护线程最典型的应用就是GC(垃圾回收器)，它就是一个很称职的守护者。</p><h1 id="第二章：对象及变量的并发访问"><a href="#第二章：对象及变量的并发访问" class="headerlink" title="第二章：对象及变量的并发访问"></a>第二章：对象及变量的并发访问</h1><h2 id="synchronized同步方法"><a href="#synchronized同步方法" class="headerlink" title="synchronized同步方法"></a>synchronized同步方法</h2><ul><li>方法内的变量为线程安全，而实例变量非线程安全。</li><li>不同线程调用<strong>同一对象</strong>里的<strong>synchronized</strong>方法时，是同步的(排队进行)。也就是必须等线程执行完<code>synchronized</code>方法时，下一线程才能执行<code>synchronized</code>方法。</li><li>可重入锁: 一个线程得到对象锁后，再次请求此对象锁时是可以得到该对象的锁的。子类也可以调用父类的同步方法。</li><li>出现异常，锁自动释放</li><li>子类方法不会继承<code>synchronized</code>关键字，需要手动在子类方法中加上。</li></ul><h2 id="synchronized同步语句块"><a href="#synchronized同步语句块" class="headerlink" title="synchronized同步语句块"></a>synchronized同步语句块</h2><ul><li>多个线程处理同一个对象的<code>synchronized(this)</code>同步语句块时，只能排队执行</li><li>同一个对象的<code>synchronized(this)</code>和<code>synchronized</code>同步方法之间也是同步的。即<strong>同一时间只有一个线程可执行synchronized代码块或方法中的代码</strong></li><li><code>synchronized(非this对象x)</code>，是将x对象作为“对象监视器”<ul><li>当多个线程同时执行<code>synchronized(x){}</code>同步代码块时呈同步效果</li><li>当其他线程执行x对象中<code>synchronizd</code>同步方法时呈同步效果</li><li>当其他线程执行x对象方法里的<code>synchronized(this)</code>代码块时呈同步效果</li></ul></li><li>静态同步    <code>synchronized</code>方法与<code>synchronized(class)</code>代码块是对Class类进行持锁。</li><li>当线程在等带根本不可能被释放的锁是，就会出现死锁。</li><li>如果同时持有相同的锁对象，线程之间就是同步的。注意对象的属性改变，运行结果还是同步的。</li></ul><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p><code>volatile</code>: 强制的从公共内存进行取值,而不是从线程私有数据栈中取得变量的值。可以使变量在多个线程间可见，但缺点是不支持原子性。</p><p><code>synchronized</code>和<code>volatile</code>比较:</p><ul><li>关键字volatile是线程同步的轻量级实现，所以volatile性能比synchronized好，并且volatile只能修饰变量，而synchronized可修饰方法和代码块。</li><li>多线程访问volatile不会发生阻塞，而synchronized会出现阻塞</li><li>volatile能保证数据可见性，不保证原子性;synchronized可以保证原子性，也可以间接保证可见性，因为synchronized会将私有内存和公共内存中的数据做同步。</li><li>volatile解决的是变量在多个线程间的可见性，synchronized解决的是多个线程访问资源的同步性（互斥加可见）。</li></ul><p>原子类:</p><p>如<code>AtomicBoolean</code>，<code>AtomicInteger</code>，<code>AtomicLong</code>等。一个原子类型就是一个原子操作可用的类型，可在没有锁的情况下做到线程安全。但原子类的方法间的调用却不是原子的，需要用同步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《java多线程编程核心技术》第一、二章的学习笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
